<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é¸£æ½®Â·è¸æ½®æ¢å†ç®—æ³•åŠ©æ‰‹ ğŸ¤–</title>
    <style>
        :root {
            --bg: #f4f7f6;
            --primary: #2ed573;
            --danger: #ff4757;
            --accent: #1e90ff;
            --card-bg: #ffffff;
            --text-main: #333333;
            --text-sub: #666666;
            --grid-gap: 6px;
        }

        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
            color: var(--text-main);
            min-height: 100vh;
        }

        /* é¡¶éƒ¨æ ‡é¢˜ */
        .header { text-align: center; margin-bottom: 20px; width: 100%; }
        .header h2 { margin: 0; font-size: 24px; letter-spacing: 1px; }

        /* æ ¸å¿ƒå¸ƒå±€ */
        .layout {
            display: flex;
            justify-content: center;
            gap: 30px;
            max-width: 1300px;
            width: 100%;
            transition: all 0.4s ease;
            box-sizing: border-box;
        }
        
        /* æ¡Œé¢ç«¯ä¼˜åŒ– */
        @media screen and (min-width: 769px) {
            .layout {
                flex-wrap: nowrap;
            }
            .grid-area {
                flex: 1 1 auto;
                min-width: 0; /* é˜²æ­¢ç½‘æ ¼æº¢å‡º */
            }
        }
        
        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media screen and (max-width: 768px) {
            .layout {
                flex-direction: column;
                gap: 15px;
                padding: 0 10px;
            }
            .config-panel {
                order: 2;
                margin-top: 10px;
                width: 100% !important;
                max-width: 100%;
                position: relative;
                top: 0;
            }
            .grid-area {
                order: 1;
                width: 100%;
                max-width: 100%;
            }
            .grid {
                width: 100%;
                max-width: 100%;
                display: grid;
                grid-template-columns: repeat(7, 1fr);
                aspect-ratio: 1/1;
            }
            .cell {
                width: 100%;
                height: 100%;
                aspect-ratio: 1/1;
            }
        }
        
        /* è¶…å°å±å¹•ä¼˜åŒ– */
        @media screen and (max-width: 480px) {
            .layout {
                gap: 10px;
                padding: 0 5px;
            }
            .config-panel {
                padding: 12px;
            }
            .grid {
                padding: 5px;
                gap: 2px;
            }
        }

        /* --- é…ç½®é¢æ¿ (å“åº”å¼) --- */
        .config-panel {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
            width: 320px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: sticky;
            top: 20px;
            overflow: visible; /* å…è®¸æŒ‰é’®æ˜¾ç¤ºåœ¨å¤–éƒ¨ */
            z-index: 100;
            flex-shrink: 0;
            /* ç§»é™¤å›ºå®šæœ€å°é«˜åº¦ï¼Œè®©å†…å®¹å†³å®šé«˜åº¦ */
            max-height: 90vh; /* é™åˆ¶æœ€å¤§é«˜åº¦ï¼Œé˜²æ­¢è¿‡é•¿ */
            overflow-y: auto; /* å¦‚æœå†…å®¹è¿‡å¤šï¼Œå¯ä»¥æ»šåŠ¨ */
        }

        .config-content { 
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        /* ç”µè„‘ç«¯æŠ˜å çŠ¶æ€ - åŸºç¡€æ ·å¼ï¼Œä¼šè¢«åª’ä½“æŸ¥è¯¢è¦†ç›– */
        .config-panel.collapsed {
            width: 10px;
            padding: 20px 5px;
            background: #eee;
            min-height: 400px; /* ä¿æŒä¸å±•å¼€æ—¶ç›¸åŒçš„æœ€å°é«˜åº¦ */
        }
        .config-panel.collapsed .config-content { 
            opacity: 0; 
            visibility: hidden; 
            pointer-events: none; 
        }

        /* åˆ‡æ¢æŒ‰é’® - åŸºç¡€æ ·å¼ï¼Œä¼šè¢«åª’ä½“æŸ¥è¯¢è¦†ç›– */
        .toggle-btn {
            position: absolute;
            right: -20px; /* å®šä½åˆ°ä¾§è¾¹æ å¤–éƒ¨ */
            top: 50%;
            transform: translateY(-50%);
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 50%; /* åœ†å½¢ */
            width: 40px; 
            height: 40px;
            cursor: pointer;
            z-index: 110;
            font-size: 16px;
            display: flex; 
            align-items: center; 
            justify-content: center;
            box-shadow: 0 4px 12px rgba(30, 144, 255, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .toggle-btn:hover {
            background: #0a7be0;
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 6px 16px rgba(30, 144, 255, 0.4);
        }
        
        /* ç§»åŠ¨ç«¯åˆ‡æ¢æŒ‰é’®æ ·å¼ */
        @media screen and (max-width: 768px) {
            .toggle-btn {
                position: relative;
                right: auto;
                top: auto;
                transform: none;
                width: 100%;
                height: auto;
                min-height: 44px;
                border-radius: 8px;
                margin-bottom: 10px;
                font-size: 14px;
                padding: 10px 15px;
                display: flex;
                align-items: center;
                justify-content: center;
                white-space: normal;
                word-break: keep-all;
                line-height: 1.4;
            }
            .toggle-btn:hover {
                transform: scale(1.02);
            }
            .config-panel .toggle-btn {
                display: flex;
            }
        }

        /* ç§»åŠ¨ç«¯æ ·å¼å°†åœ¨åª’ä½“æŸ¥è¯¢ä¸­è¦†ç›– */

        /* --- ç½‘æ ¼åŒºåŸŸ --- */
        .grid-area { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            max-width: 600px;
            transition: all 0.3s ease;
        }
        
        /* ç§»åŠ¨ç«¯é…ç½®é¢æ¿æŠ˜å æ—¶ï¼Œç½‘æ ¼åŒºåŸŸå¯ä»¥æ›´å¤§ */
        @media screen and (max-width: 768px) {
            .config-panel.collapsed {
                max-height: 60px;
                overflow: hidden;
                padding: 10px;
            }
            .config-panel.collapsed .config-content {
                display: none;
            }
            .config-panel:not(.collapsed) {
                max-height: 70vh;
                overflow-y: auto;
            }
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(7, 60px);
            gap: var(--grid-gap);
            background: var(--card-bg);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.1);
            position: relative;
            z-index: 1;
        }

        .cell {
            width: 60px; 
            height: 60px;
            background: #f8f9fa;
            border: 1px solid #eee;
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center;
            cursor: pointer; 
            border-radius: 8px;
            position: relative;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        /* éšå½¢æ°´å° */
        .grid::after {
            content: "Designed by @Darkå™«æœ¯å®¶";
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) rotate(-30deg);
            font-size: 24px;
            color: rgba(0, 0, 0, 0.04);
            white-space: nowrap;
            pointer-events: none;
            z-index: 10;
        }

        .cell {
            width: 55px; height: 55px;
            background: #f8f9fa;
            border: 1px solid #eee;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            cursor: pointer; border-radius: 8px;
            position: relative;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        .cell:hover:not(.opened) { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0,0,0,0.1); border-color: var(--accent); }
        .cell .coord { font-size: 8px; color: #ccc; position: absolute; top: 2px; left: 4px; }
        .cell .score { font-size: 11px; font-weight: bold; margin-top: 4px; }

        .cell.opened { background: #fff !important; border-color: #f0f0f0; cursor: default; }
        .cell.opened::after { content: 'âœ…'; font-size: 16px; }
        .cell.opened .score, .cell.opened .coord { display: none; }

        .cell.best { background: var(--danger) !important; color: white; z-index: 5; box-shadow: 0 0 15px rgba(255,71,87,0.4); border: none; }
        .cell.good { background: #ffa502 !important; color: white; z-index: 4; border: none; }
        .cell.combined-best { 
            border: 3px solid #00ff00 !important; 
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.7) !important;
            animation: pulse-green 2s infinite;
            z-index: 6;
        }
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 255, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0); }
        }

        /* å…¶ä»–ç»„ä»¶ */
        .prob-input-group { margin-bottom: 8px; display: flex; align-items: center; justify-content: space-between; font-size: 13px; }
        .prob-input-group input { width: 50px; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center; }
        .status-bar { 
            margin-top: 15px; 
            padding: 10px; 
            border-radius: 10px; 
            background: #fff; 
            font-size: 13px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.05); 
            width: 100%; 
            text-align: center; 
            box-sizing: border-box;
            word-break: break-word;
        }
        
        @media screen and (max-width: 768px) {
            .status-bar {
                font-size: 12px;
                padding: 8px;
                margin-top: 10px;
                line-height: 1.4;
            }
        }
        
        @media screen and (max-width: 480px) {
            .status-bar {
                font-size: 11px;
                padding: 6px;
            }
        }
        .btn-reset { 
            margin-top: 15px; 
            width: 100%; 
            padding: 14px; 
            background: #2d3436; 
            color: white; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            font-weight: bold; 
            font-size: 16px;
            -webkit-tap-highlight-color: transparent;
        }
        @media screen and (max-width: 768px) {
            .btn-reset {
                padding: 12px;
                font-size: 14px;
            }
        }

        /* ç®—æ³•éƒ¨åˆ†å¼ºè°ƒæ ·å¼ */
        .algorithm-highlight {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .algorithm-title {
            margin-top: 0;
            font-size: 18px;
            color: var(--accent);
            display: flex;
            align-items: center;
        }
        
        .algorithm-select {
            width: 180px;
            padding: 6px;
            border: 2px solid var(--accent);
            border-radius: 6px;
            font-weight: bold;
            background: white;
        }

        /* æ¡Œé¢ç«¯æ ·å¼ä¼˜åŒ– */
        @media screen and (min-width: 769px) {
            .layout {
                align-items: flex-start; /* é˜²æ­¢å­å…ƒç´ è¢«æ‹‰ä¼¸ */
            }
            .config-panel {
                height: auto;
                position: sticky;
                top: 20px;
                max-height: 700px; /* é™åˆ¶æœ€å¤§é«˜åº¦ */
                overflow-y: auto; /* å…è®¸æ»šåŠ¨ */
            }
            .config-panel.collapsed {
                width: 20px !important; /* æŠ˜å å®½åº¦ï¼Œæ›´çª„ä»¥é€‚åº”åœ†å½¢æŒ‰é’® */
                height: auto; /* é«˜åº¦ç”±å†…å®¹å†³å®š */
                min-height: auto;
                max-height: 700px; /* ä¸å±•å¼€æ—¶ç›¸åŒçš„æœ€å¤§é«˜åº¦ */
                padding: 20px 5px !important;
                background: #eee;
                overflow: hidden; /* éšè—æº¢å‡ºçš„å†…å®¹ */
            }
            .config-panel.collapsed .config-content { 
                opacity: 0; 
                visibility: hidden; 
                pointer-events: none; 
                height: 0; /* ä¸å é«˜åº¦ */
                overflow: hidden;
            }
            .toggle-btn {
                position: absolute;
                top: 50%;
                right: -20px; /* å®šä½åˆ°ä¾§è¾¹æ å³ä¾§å¤–éƒ¨ */
                transform: translateY(-50%);
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background: var(--accent);
                color: white;
                z-index: 110;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 4px 12px rgba(30, 144, 255, 0.3);
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }
            .toggle-btn:hover {
                background: #0a7be0;
                transform: translateY(-50%) scale(1.1);
                box-shadow: 0 6px 16px rgba(30, 144, 255, 0.4);
            }
        }

        /* æ‰‹æœºç«¯é€‚é… (å…³é”®ä¿®æ”¹) */
        @media screen and (max-width: 768px) {
            body {
                padding: 10px;
            }
            .layout { 
                flex-direction: column; 
                align-items: center;
                gap: 10px;
            }
            .config-panel {
                position: relative; 
                top: 0; 
                width: 100% !important; 
                order: 2;
                margin-top: 10px; 
                padding: 15px; 
                height: auto;
                border-radius: 12px;
                max-width: 100%;
                min-height: auto !important; /* è¦†ç›–æ¡Œé¢ç«¯çš„æœ€å°é«˜åº¦ */
                max-height: none !important; /* è¦†ç›–æ¡Œé¢ç«¯çš„æœ€å¤§é«˜åº¦ */
                overflow-y: visible !important;
            }
            .config-panel.collapsed {
                height: auto; 
                width: 100% !important; 
                padding: 15px;
                min-height: auto !important; /* è¦†ç›–æ¡Œé¢ç«¯çš„æœ€å°é«˜åº¦ */
                max-height: none !important;
                overflow: hidden;
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            .toggle-btn {
                position: relative; /* è¦†ç›–æ¡Œé¢ç«¯çš„ç»å¯¹å®šä½ */
                right: auto; 
                top: auto;
                transform: none;
                width: 100%; /* æ”¹ä¸ºå…¨å®½é•¿æ–¹å½¢ */
                height: auto;
                min-height: 44px;
                border-radius: 8px;
                background: var(--accent);
                color: white;
                font-weight: bold;
                font-size: 16px;
                margin: 0 0 10px 0; /* å»æ‰å±…ä¸­ï¼Œæ”¹ä¸ºæ­£å¸¸è¾¹è· */
                box-shadow: 0 4px 12px rgba(30, 144, 255, 0.3);
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 10px 15px;
                white-space: normal;
                word-break: keep-all;
                line-height: 1.4;
                text-align: center;
            }
            .toggle-btn:hover {
                background: #0a7be0;
                transform: scale(1.02);
            }
            .grid-area {
                max-width: 100%;
            }
            .grid {
                grid-template-columns: repeat(7, 12vw);
                gap: 3px;
                padding: 8px;
                border-radius: 12px;
            }
            .cell { 
                width: 12vw; 
                height: 12vw; 
                border-radius: 6px;
            }
            .cell .coord { 
                font-size: 7px; 
                top: 1px; 
                left: 2px; 
            }
            .cell .score { 
                font-size: 9px; 
                margin-top: 2px; 
            }
            .watermark { 
                display: none; 
            }
            .header { 
                margin-bottom: 10px; 
            }
            .header h2 { 
                font-size: 18px; 
                padding: 0 10px;
                text-align: center;
            }
            .status-bar {
                margin-top: 10px;
                padding: 8px;
                font-size: 12px;
                border-radius: 8px;
            }
            .prob-input-group {
                font-size: 12px;
                margin-bottom: 6px;
            }
            .prob-input-group input,
            .prob-input-group select {
                width: 45px;
                padding: 5px 3px;
                font-size: 12px;
                min-height: 28px;
                box-sizing: border-box;
            }
            .prob-input-group select {
                width: 180px;
            }
            h3 {
                font-size: 14px !important;
                margin-top: 15px !important;
            }
            #simResults {
                font-size: 11px;
            }
            #simResultsContent {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            #simResultsContent table {
                font-size: 10px;
                min-width: 300px;
            }
            #simResultsContent div[style*="grid-template-columns"] {
                grid-template-columns: repeat(7, 1fr);
                gap: 1px;
            }
            #simResultsContent div[style*="grid-template-columns"] div {
                font-size: 7px;
                padding: 2px;
            }
        }
        
        /* è¶…å°å±å¹•é€‚é… */
        @media screen and (max-width: 360px) {
            .grid {
                grid-template-columns: repeat(7, 10vw);
                gap: 2px;
                padding: 6px;
            }
            .cell { 
                width: 10vw; 
                height: 10vw; 
                border-radius: 4px;
            }
            .cell .coord { 
                font-size: 6px; 
                top: 1px; 
                left: 1px; 
            }
            .cell .score { 
                font-size: 8px; 
                margin-top: 1px; 
            }
            .header h2 { 
                font-size: 15px; 
            }
            .config-panel {
                padding: 12px;
            }
            .toggle-btn {
                font-size: 12px;
                height: 45px;
            }
            .prob-input-group {
                font-size: 11px;
            }
            .prob-input-group input {
                width: 40px;
                font-size: 11px;
            }
            #simResultsContent table {
                min-width: 280px;
                font-size: 9px;
            }
            #simResultsContent div[style*="grid-template-columns"] div {
                font-size: 6px;
                padding: 1px;
            }
        }

        /* æµ®åŠ¨èœå• */
        #menu { display: none; position: fixed; background: white; border-radius: 12px; box-shadow: 0 15px 50px rgba(0,0,0,0.2); padding: 15px; z-index: 1000; min-width: 180px; }
        .menu-btn { display: block; width: 100%; padding: 10px; margin-bottom: 6px; border: none; background: #f8f9fa; border-radius: 8px; cursor: pointer; text-align: left; font-size: 13px; }
        .menu-btn:hover { background: var(--accent); color: white; }

        .watermark { position: fixed; top: 15px; right: 15px; background: rgba(255,255,255,0.9); padding: 8px 12px; border-radius: 10px; border-left: 4px solid var(--accent); box-shadow: 0 10px 25px rgba(0,0,0,0.1); z-index: 1000; font-size: 12px; }

        /* å‘¼å¸ç¯ç‰¹æ•ˆ */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(46, 213, 115, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(46, 213, 115, 0); }
            100% { box-shadow: 0 0 0 0 rgba(46, 213, 115, 0); }
        }
        .algorithm-pulse {
            animation: pulse 2s infinite;
            border-radius: 8px;
            padding: 2px 8px;
        }

        /* æ­å–œå¼¹çª— */
        #winOverlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(8px); z-index: 2000;
            flex-direction: column; justify-content: center; align-items: center;
        }
        .win-card { background: #fff; padding: 30px; border-radius: 20px; text-align: center; width: 80%; max-width: 320px; animation: popIn 0.5s ease forwards; }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>

<div class="watermark">
    <b>ğŸ“º Bç«™@Darkå™«æœ¯å®¶</b>
</div>

<div class="header">
    <h2>é¸£æ½®âœ¨è¸æ½®æ¢å†å°åŠ©æ‰‹ ğŸ¤–</h2>
</div>

<div class="layout">
    <div class="config-panel" id="configPanel">
        <button class="toggle-btn" onclick="toggleConfig()" id="toggleBtn">â—€</button>
        <div class="config-content">
            <!-- ç®—æ³•é€‰æ‹©éƒ¨åˆ†ç§»åˆ°æœ€å‰é¢ï¼Œå¹¶å¢åŠ è§†è§‰å¼ºè°ƒ -->
            <div style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 12px; padding: 15px; margin-bottom: 20px; border-left: 4px solid var(--accent); box-shadow: 0 5px 15px rgba(0,0,0,0.05);">
                <h3 style="margin-top:0; font-size:18px; color: var(--accent); display:flex; align-items:center;">
                    <span style="margin-right:8px;">ğŸ¤–</span> æ ¸å¿ƒç®—æ³•é€‰æ‹©
                </h3>
                <div style="margin-bottom:10px;">
                    <div class="prob-input-group">
                        <label style="font-weight:bold;">å½“å‰ç®—æ³•</label>
                        <select id="algorithmSelect" onchange="updateAlgorithm(this.value)" style="width:180px; padding:6px; border:2px solid var(--accent); border-radius:6px; font-weight:bold; background:white;">
                            <option value="greedy">è´ªå¿ƒç®—æ³•ï¼ˆåˆ©ç›Šè‡³ä¸Šï¼‰</option>
                            <option value="heuristic">å¸¦æƒå¯å‘ï¼ˆæˆ˜ç•¥å¸ƒå±€ï¼‰</option>
                            <option value="entropy">ç†µå‡ç®—æ³•ï¼ˆé£é™©å¯¹å†²ï¼‰</option>
                            <option value="comprehensive">ç»¼åˆæ¨èï¼ˆç®—æ³•èåˆï¼‰</option>
                            <option value="mcts">è’™ç‰¹å¡æ´›æœç´¢ï¼ˆæ·±åº¦å‰ç»ï¼‰</option>
                            <option value="fastMCTS">å¿«é€Ÿè’™ç‰¹å¡æ´›ï¼ˆå¹³è¡¡å‹ï¼‰</option>
                        </select>
                    </div>
                    <div class="prob-input-group" id="weightParamGroup" style="display:none;">
                        <label>æ¢ç´¢æƒé‡ (w)</label>
                        <input type="number" id="heuristicWeight" value="1.0" step="0.1" min="0.1" max="5.0" onchange="updateHeuristicWeight(this.value)" style="width:60px; padding:4px; border:1px solid #ddd; border-radius:4px;">
                    </div>
                    <div class="prob-input-group" id="autoWeightGroup" style="display:none;">
                        <label>æƒé‡è‡ªåŠ¨è°ƒæ•´</label>
                        <input type="checkbox" id="autoWeight" onchange="toggleAutoWeight(this.checked)" style="width:auto;">
                    </div>
                    <div id="comprehensiveParamGroup" style="display:none; margin-top:10px;">
                        <div style="font-size:12px; margin-bottom:5px; color:#666; font-weight:bold;">å‚ä¸ç»¼åˆçš„ç®—æ³•ï¼š</div>
                        <div style="display:flex; flex-wrap:wrap; gap:8px;">
                            <label style="font-size:11px; display:flex; align-items:center; background:#fff; padding:4px 8px; border-radius:4px; border:1px solid #ddd;">
                                <input type="checkbox" id="compGreedy" checked onchange="updateComprehensiveAlgorithms()"> è´ªå¿ƒ
                            </label>
                            <label style="font-size:11px; display:flex; align-items:center; background:#fff; padding:4px 8px; border-radius:4px; border:1px solid #ddd;">
                                <input type="checkbox" id="compHeuristic" checked onchange="updateComprehensiveAlgorithms()"> å¸¦æƒå¯å‘
                            </label>
                            <label style="font-size:11px; display:flex; align-items:center; background:#fff; padding:4px 8px; border-radius:4px; border:1px solid #ddd;">
                                <input type="checkbox" id="compEntropy" checked onchange="updateComprehensiveAlgorithms()"> ç†µå‡
                            </label>
                            <label style="font-size:11px; display:flex; align-items:center; background:#fff; padding:4px 8px; border-radius:4px; border:1px solid #ddd;">
                                <input type="checkbox" id="compMCTS" onchange="updateComprehensiveAlgorithms()"> è’™ç‰¹å¡æ´›
                            </label>
                        </div>
                    </div>
                    <div id="mctsParamGroup" style="display:none; margin-top:10px;">
                        <div class="prob-input-group">
                            <label>æ¨¡æ‹Ÿæ¬¡æ•°</label>
                            <input type="number" id="mctsIterations" value="300" min="100" max="2000" onchange="updateMCTSIterations(this.value)" style="width:70px;">
                        </div>
                        <div class="prob-input-group">
                            <label>ç¨³å®šæ€§æ¨¡å¼</label>
                            <input type="checkbox" id="mctsStable" checked onchange="updateMCTSStable(this.checked)" style="width:auto;">
                        </div>
                        <div style="font-size:11px; color:#666; margin-top:5px; padding:5px; background:#f8f9fa; border-radius:4px;">
                            <b>æ³¨æ„ï¼š</b> è’™ç‰¹å¡æ´›åŸºäºéšæœºæ¨¡æ‹Ÿï¼Œç»“æœä¼šæœ‰æ­£å¸¸æ³¢åŠ¨ã€‚å¼€å¯ç¨³å®šæ€§æ¨¡å¼å¯å‡å°‘æ³¢åŠ¨ã€‚
                        </div>
                    </div>
                    <div id="weightHelp" style="display:none; font-size:11px; color:#666; margin-top:8px; padding:8px; background:#fff; border-radius:6px; border:1px dashed #ddd;">
                        <b>æ¢ç´¢æƒé‡è¯´æ˜ï¼š</b> wå€¼è¶Šå¤§ï¼Œç®—æ³•è¶Šå€¾å‘äºé€‰æ‹©å‘¨å›´æœªå¼€æ ¼å­å¤šçš„ä½ç½®ï¼ˆæ¢ç´¢ï¼‰ï¼Œwå€¼è¶Šå°åˆ™è¶Šå…³æ³¨å½“å‰æ ¼å­ç›´æ¥æ”¶ç›Šï¼ˆåˆ©ç”¨ï¼‰ã€‚æ¨èå€¼ï¼š1.0-2.0ã€‚
                    </div>
                </div>
                <div style="font-size:11px; color:#666; margin-top:8px; padding:8px; background:rgba(255,255,255,0.7); border-radius:6px;">
                    <b>ğŸ’¡ ç®—æ³•æç¤ºï¼š</b> çº¢è‰²æ ¼å­ä¸ºå½“å‰ç®—æ³•æ¨èçš„æœ€ä½³é€‰æ‹©ã€‚è’™ç‰¹å¡æ´›æœç´¢é€‚åˆä¸­åæœŸå¤æ‚å±€é¢ã€‚
                </div>
            </div>
            
            <h3 style="margin-top:0; font-size:16px;">âš™ï¸ æ¦‚ç‡æƒé‡</h3>
            <div id="probInputs"></div>
            <div id="probWarning" style="font-size: 12px; margin: 8px 0;"></div>
            
            <h3 style="margin-top:25px; font-size:16px;">ğŸ¯ ä¿åº•ç³»ç»Ÿ</h3>
            <div style="margin-bottom:15px;">
                <div class="prob-input-group">
                    <label>å¯ç”¨ä¿åº•</label>
                    <input type="checkbox" id="enablePity" onchange="updatePityEnable(this.checked)" style="width:auto;">
                </div>
                <div class="prob-input-group">
                    <label>ä¿åº•èµ·å§‹ (X)</label>
                    <input type="number" id="pityStart" onchange="updatePityStart(this.value)" min="1" max="20">
                </div>
                <div class="prob-input-group">
                    <label>ä¿åº•ä¸Šé™ (Y)</label>
                    <input type="number" id="pityMax" onchange="updatePityMax(this.value)" min="2" max="50">
                </div>
                <div style="font-size:11px; color:#888; margin-top:8px; padding:6px; background:#f8f9fa; border-radius:6px;">
                    å½“å‰æœªè§¦å‘è®¡æ•°: <span id="currentMissesDisplay"></span>
                </div>
            </div>

            <h3 style="margin-top:20px; font-size:16px;">ğŸ’ª æ‰¹é‡æ¨¡æ‹Ÿ</h3>
            <div style="margin-bottom:10px;">
                <div class="prob-input-group">
                    <label>æ¨¡æ‹Ÿæ¬¡æ•°</label>
                    <input type="number" id="simIterations" value="1000" min="10" max="10000" style="width:70px;">
                </div>
                <button class="btn-reset" onclick="runBatchSimulation()" style="margin-top:10px; background:var(--accent); padding: 12px; font-size: 14px;">å¼€å§‹æ‰¹é‡æ¨¡æ‹Ÿ</button>
                <div id="simResults" style="margin-top:15px; font-size:12px; display:none;">
                    <h4 style="margin:0 0 8px 0; font-size:13px;">æ¨¡æ‹Ÿç»“æœ</h4>
                    <div id="simResultsContent" style="overflow-x: auto;"></div>
                </div>
            </div>
            
            <button class="btn-reset" onclick="confirmReset()">ğŸ”„ é‡ç½®è¿›åº¦</button>
        </div>
    </div>

    <div class="grid-area">
        <div class="grid" id="grid"></div>
        <div class="status-bar" id="statusBar">â³ ç­‰å¾…æ“ä½œ...</div>
    </div>
</div>

<div id="menu">
    <h4 style="margin:0 0 10px 0; font-size:14px;">âœ¨ è§¦å‘äº‹ä»¶</h4>
    <div id="menuButtons"></div>
    <button class="menu-btn" onclick="closeMenu()" style="background:#eee; text-align:center; margin-top:5px;">å–æ¶ˆ</button>
</div>

<div id="winOverlay">
    <div class="win-card">
        <h2>ğŸ‰ æ¢å†è¾¾æˆï¼</h2>
        <p id="winMessage" style="color:#666; font-size:14px; line-height:1.6;"></p>
        <button onclick="confirmReset()" style="padding: 10px 20px; background: var(--primary); color:white; border:none; border-radius:8px; cursor:pointer; width:100%; font-weight:bold;">å¼€å¯æ–°ä¸€è½® ğŸš€</button>
    </div>
</div>

<script>
const size = 7;
const STORAGE_KEY = 'MC_EVENT_HELPER_V1.2_MOBILE';
const defaultData = {
    grid: Array(size * size).fill(false),
    probs: [50, 11, 11, 5, 13, 9, 1],
    clicks: 0,
    enablePity: true,
    pityStart: 3,
    pityMax: 5,
    currentMisses: 0,
    currentAlgorithm: 'greedy',
    heuristicWeight: 1.0,
    autoWeight: true,
    mctsIterations: 300,
    mctsStable: true,
    comprehensiveAlgorithms: {
        greedy: true,
        heuristic: true,
        entropy: true,
        mcts: false
    }
};

let state = loadState();
let activePos = { r: -1, c: -1 };

// --- é€‚é…ä¸æŠ˜å é€»è¾‘ ---
function toggleConfig() {
    const panel = document.getElementById('configPanel');
    const btn = document.getElementById('toggleBtn');
    const isMobile = window.innerWidth <= 768;

    panel.classList.toggle('collapsed');

    if (panel.classList.contains('collapsed')) {
        // æŠ˜å çŠ¶æ€
        if (isMobile) {
            btn.innerHTML = 'ğŸ”½ æ˜¾ç¤ºè®¾ç½®';
        } else {
            btn.innerHTML = 'â–¶';
        }
    } else {
        // å±•å¼€çŠ¶æ€
        if (isMobile) {
            btn.innerHTML = 'ğŸ”¼ éšè—è®¾ç½®';
        } else {
            btn.innerHTML = 'â—€';
        }
    }
    
    // åœ¨ç§»åŠ¨ç«¯ï¼Œæ»šåŠ¨åˆ°é¡¶éƒ¨ä»¥ä¾¿çœ‹åˆ°ç½‘æ ¼
    if (isMobile && !panel.classList.contains('collapsed')) {
        setTimeout(() => {
            panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }, 100);
    }
}

function loadState() {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (!saved) {
        return JSON.parse(JSON.stringify(defaultData));
    }
    
    try {
        const loaded = JSON.parse(saved);
        // ç¡®ä¿æ‰€æœ‰å­—æ®µéƒ½å­˜åœ¨ï¼Œä½¿ç”¨é»˜è®¤å€¼å¡«å……ç¼ºå¤±å­—æ®µ
        const result = {
            ...JSON.parse(JSON.stringify(defaultData)),
            ...loaded
        };
        
        // ç¡®ä¿æ•°ç»„æ˜¯æ–°çš„å¼•ç”¨
        result.grid = Array.isArray(loaded.grid) ? [...loaded.grid] : [...defaultData.grid];
        result.probs = Array.isArray(loaded.probs) ? [...loaded.probs] : [...defaultData.probs];
        
        // ç¡®ä¿æ•°å€¼å­—æ®µæ­£ç¡®
        result.clicks = Number.isInteger(loaded.clicks) ? loaded.clicks : defaultData.clicks;
        result.enablePity = typeof loaded.enablePity === 'boolean' ? loaded.enablePity : defaultData.enablePity;
        result.pityStart = Number.isInteger(loaded.pityStart) ? loaded.pityStart : defaultData.pityStart;
        result.pityMax = Number.isInteger(loaded.pityMax) ? loaded.pityMax : defaultData.pityMax;
        result.currentMisses = Number.isInteger(loaded.currentMisses) ? loaded.currentMisses : defaultData.currentMisses;
        // å¤„ç†ç®—æ³•æ ‡è¯†ç¬¦çš„è½¬æ¢ï¼šå°†'weighted'è½¬æ¢ä¸º'heuristic'
        let loadedAlgorithm = typeof loaded.currentAlgorithm === 'string' ? loaded.currentAlgorithm : defaultData.currentAlgorithm;
        if (loadedAlgorithm === 'weighted') {
            loadedAlgorithm = 'heuristic';
        }
        result.currentAlgorithm = loadedAlgorithm;
        result.heuristicWeight = typeof loaded.heuristicWeight === 'number' ? loaded.heuristicWeight : defaultData.heuristicWeight;
        result.autoAlgorithm = typeof loaded.autoAlgorithm === 'boolean' ? loaded.autoAlgorithm : defaultData.autoAlgorithm;
        result.autoWeight = typeof loaded.autoWeight === 'boolean' ? loaded.autoWeight : defaultData.autoWeight;
        
        // ç¡®ä¿gridé•¿åº¦æ­£ç¡®
        if (result.grid.length !== 49) {
            result.grid = Array(49).fill(false);
        }
        
        return result;
    } catch (e) {
        console.error('åŠ è½½çŠ¶æ€å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼:', e);
        return JSON.parse(JSON.stringify(defaultData));
    }
}

function saveState() { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

function init() {
    // ç¡®ä¿çŠ¶æ€æ­£ç¡®åŠ è½½
    state = loadState();
    
    // æ¸²æŸ“è¾“å…¥æ¡†
    const probContainer = document.getElementById('probInputs');
    probContainer.innerHTML = '';
    const labels = ["ä»…å½“å‰ ğŸ“", "åŒåˆ— â†•ï¸", "åŒè¡Œ â†”ï¸", "åŒè¡ŒåŒåˆ— â•", "åå­— ğŸ’ ", "ä¹å®«æ ¼ ğŸ·", "å…¨å¼€ ğŸŒŸ"];

    labels.forEach((label, i) => {
        const div = document.createElement('div');
        div.className = 'prob-input-group';
        div.innerHTML = `<label>${label}</label><input type="number" id="p${i}" value="${state.probs[i]}" onchange="updateProbs(${i}, this.value)" min="0" max="100">`;
        probContainer.appendChild(div);
    });

    // æ¸²æŸ“ä¿åº•é…ç½®
    document.getElementById('enablePity').checked = state.enablePity;
    document.getElementById('pityStart').value = state.pityStart;
    document.getElementById('pityMax').value = state.pityMax;
    document.getElementById('currentMissesDisplay').textContent = state.currentMisses;
    
    // æ¸²æŸ“ç®—æ³•é€‰æ‹©
    document.getElementById('algorithmSelect').value = state.currentAlgorithm;
    document.getElementById('heuristicWeight').value = state.heuristicWeight;
    document.getElementById('autoWeight').checked = state.autoWeight;
    document.getElementById('mctsIterations').value = state.mctsIterations || 300;
    document.getElementById('mctsStable').checked = state.mctsStable !== false;
    
    // åˆå§‹åŒ–ç»¼åˆæ¨èç®—æ³•é€‰æ‹©
    if (!state.comprehensiveAlgorithms) {
        state.comprehensiveAlgorithms = {
            greedy: true,
            heuristic: true,
            entropy: true,
            mcts: false
        };
    }
    document.getElementById('compGreedy').checked = state.comprehensiveAlgorithms.greedy;
    document.getElementById('compHeuristic').checked = state.comprehensiveAlgorithms.heuristic;
    document.getElementById('compEntropy').checked = state.comprehensiveAlgorithms.entropy;
    document.getElementById('compMCTS').checked = state.comprehensiveAlgorithms.mcts || false;
    
    // æ ¹æ®ç®—æ³•æ˜¾ç¤º/éšè—å‚æ•°ç»„
    const weightGroup = document.getElementById('weightParamGroup');
    const comprehensiveGroup = document.getElementById('comprehensiveParamGroup');
    const mctsGroup = document.getElementById('mctsParamGroup');
    const weightHelp = document.getElementById('weightHelp');
    
    if (state.currentAlgorithm === 'heuristic') {
        weightGroup.style.display = 'flex';
        comprehensiveGroup.style.display = 'none';
        mctsGroup.style.display = 'none';
        weightHelp.style.display = 'block';
    } else if (state.currentAlgorithm === 'comprehensive') {
        weightGroup.style.display = 'none';
        comprehensiveGroup.style.display = 'block';
        mctsGroup.style.display = 'none';
        weightHelp.style.display = 'none';
    } else if (state.currentAlgorithm === 'mcts' || state.currentAlgorithm === 'fastMCTS') {
        weightGroup.style.display = 'none';
        comprehensiveGroup.style.display = 'none';
        mctsGroup.style.display = 'block';
        weightHelp.style.display = 'none';
    } else {
        weightGroup.style.display = 'none';
        comprehensiveGroup.style.display = 'none';
        mctsGroup.style.display = 'none';
        weightHelp.style.display = 'none';
    }

    // æ¸²æŸ“ç½‘æ ¼
    const gridEl = document.getElementById('grid');
    gridEl.innerHTML = '';
    for (let i = 0; i < 49; i++) {
        const r = Math.floor(i / 7), c = i % 7;
        const cell = document.createElement('div');
        cell.className = 'cell' + (state.grid[i] ? ' opened' : '');
        cell.id = `cell-${i}`;
        cell.innerHTML = `<span class="coord">${r+1},${c+1}</span><span class="score" id="s-${i}">0</span>`;
        cell.onclick = (e) => showMenu(r, c, e);
        gridEl.appendChild(cell);
    }

    // æ¸²æŸ“èœå•æŒ‰é’®
    const menuBtns = document.getElementById('menuButtons');
    menuBtns.innerHTML = '';
    labels.forEach((label, i) => {
        const btn = document.createElement('button');
        btn.className = 'menu-btn';
        btn.innerText = label;
        btn.onclick = () => applyEvent(i + 1);
        menuBtns.appendChild(btn);
    });
    
    // åˆå§‹åŒ–æŠ˜å æŒ‰é’®çŠ¶æ€
    const isMobile = window.innerWidth <= 768;
    const btn = document.getElementById('toggleBtn');
    const panel = document.getElementById('configPanel');
    
    if (isMobile) {
        // ç§»åŠ¨ç«¯é»˜è®¤æŠ˜å é…ç½®é¢æ¿ï¼Œä»¥æä¾›æ›´å¤šç©ºé—´ç»™ç½‘æ ¼
        panel.classList.add('collapsed');
        btn.innerHTML = 'ğŸ”½ æ˜¾ç¤ºè®¾ç½®';
    } else {
        btn.innerHTML = 'â—€';
    }
    
    updateAnalysis();
    
    // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼Œè°ƒæ•´æŠ˜å çŠ¶æ€
    window.addEventListener('resize', function() {
        const isMobileNow = window.innerWidth <= 768;
        const panel = document.getElementById('configPanel');
        const btn = document.getElementById('toggleBtn');
        
        if (isMobileNow) {
            // åœ¨ç§»åŠ¨ç«¯ï¼Œç¡®ä¿æŒ‰é’®æ˜¾ç¤ºæ­£ç¡®
            if (panel.classList.contains('collapsed')) {
                btn.innerHTML = 'ğŸ”½ æ˜¾ç¤ºè®¾ç½®';
            } else {
                btn.innerHTML = 'ğŸ”¼ éšè—è®¾ç½®';
            }
        } else {
            // åœ¨æ¡Œé¢ç«¯
            if (panel.classList.contains('collapsed')) {
                btn.innerHTML = 'â–¶';
            } else {
                btn.innerHTML = 'â—€';
            }
        }
    });
}

// --- éŸ³æ•ˆç³»ç»Ÿ ---
function playEffect(type) {
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const now = audioCtx.currentTime;
    const osc = (f, s, d, w='sine') => {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = w; o.frequency.setValueAtTime(f, s);
        g.gain.setValueAtTime(0.08, s); g.gain.exponentialRampToValueAtTime(0.0001, s + d);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(s); o.stop(s + d);
    };
    if(type === 1) osc(880, now, 0.1);
    else if(type === 7) [523, 659, 783, 1046].forEach((f, i) => osc(f, now + i*0.1, 0.5));
    else osc(587, now, 0.15, 'triangle');
}

// --- é€»è¾‘å¤„ç† ---
function updateProbs(i, val) { state.probs[i] = parseInt(val) || 0; updateAnalysis(); }
function updatePityEnable(checked) { state.enablePity = checked; updateAnalysis(); }
function updatePityStart(val) { state.pityStart = parseInt(val) || 3; updateAnalysis(); }
function updatePityMax(val) { state.pityMax = parseInt(val) || 5; updateAnalysis(); }
function updateAlgorithm(val) {
    state.currentAlgorithm = val;
    
    const weightGroup = document.getElementById('weightParamGroup');
    const autoWeightGroup = document.getElementById('autoWeightGroup');
    const comprehensiveGroup = document.getElementById('comprehensiveParamGroup');
    const mctsGroup = document.getElementById('mctsParamGroup');
    const weightHelp = document.getElementById('weightHelp');
    
    if (val === 'heuristic') {
        weightGroup.style.display = 'flex';
        autoWeightGroup.style.display = 'flex';
        comprehensiveGroup.style.display = 'none';
        mctsGroup.style.display = 'none';
        weightHelp.style.display = 'block';
    } else if (val === 'comprehensive') {
        weightGroup.style.display = 'none';
        autoWeightGroup.style.display = 'none';
        comprehensiveGroup.style.display = 'block';
        mctsGroup.style.display = 'none';
        weightHelp.style.display = 'none';
    } else if (val === 'mcts' || val === 'fastMCTS') {
        weightGroup.style.display = 'none';
        autoWeightGroup.style.display = 'none';
        comprehensiveGroup.style.display = 'none';
        mctsGroup.style.display = 'block';
        weightHelp.style.display = 'none';
    } else {
        weightGroup.style.display = 'none';
        autoWeightGroup.style.display = 'none';
        comprehensiveGroup.style.display = 'none';
        mctsGroup.style.display = 'none';
        weightHelp.style.display = 'none';
    }
    updateAnalysis();
}

function updateHeuristicWeight(val) {
    // å¦‚æœè‡ªåŠ¨è°ƒæ•´å¼€å¯ï¼Œæç¤ºç”¨æˆ·
    if (state.autoWeight && state.currentAlgorithm === 'heuristic') {
        if (confirm('æƒé‡è‡ªåŠ¨è°ƒæ•´å·²å¼€å¯ï¼Œæ‰‹åŠ¨ä¿®æ”¹æƒé‡å°†å…³é—­è‡ªåŠ¨è°ƒæ•´ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ')) {
            state.autoWeight = false;
            document.getElementById('autoWeight').checked = false;
            state.heuristicWeight = parseFloat(val) || 1.0;
        } else {
            // æ¢å¤åŸæ¥çš„å€¼
            document.getElementById('heuristicWeight').value = state.heuristicWeight.toFixed(1);
            return;
        }
    } else {
        state.heuristicWeight = parseFloat(val) || 1.0;
    }
    updateAnalysis();
}

function toggleAutoWeight(checked) {
    state.autoWeight = checked;
    updateAnalysis();
}

function updateComprehensiveAlgorithms() {
    // ä¿å­˜é€‰æ‹©çš„ç®—æ³•åˆ°state
    state.comprehensiveAlgorithms = {
        greedy: document.getElementById('compGreedy').checked,
        heuristic: document.getElementById('compHeuristic').checked,
        entropy: document.getElementById('compEntropy').checked,
        mcts: document.getElementById('compMCTS').checked
    };
    updateAnalysis();
}

function updateMCTSIterations(val) {
    state.mctsIterations = parseInt(val) || 300;
    updateAnalysis();
}

function updateMCTSStable(checked) {
    state.mctsStable = checked;
    updateAnalysis();
}

function showMenu(r, c, e) {
    if (state.grid[r * 7 + c]) return;
    activePos = { r, c };
    const menu = document.getElementById('menu');
    menu.style.display = 'block';
    
    // è·å–ç‚¹å‡»ä½ç½®
    const clickX = e.clientX || e.pageX;
    const clickY = e.clientY || e.pageY;
    
    // èœå•å°ºå¯¸
    const menuWidth = 200;
    const menuHeight = 300;
    
    // è®¡ç®—ä½ç½®ï¼Œç¡®ä¿åœ¨è§†å£å†…
    let left = clickX;
    let top = clickY;
    
    // æ£€æŸ¥å³è¾¹ç•Œ
    if (left + menuWidth > window.innerWidth) {
        left = window.innerWidth - menuWidth - 10;
    }
    // æ£€æŸ¥ä¸‹è¾¹ç•Œ
    if (top + menuHeight > window.innerHeight) {
        top = window.innerHeight - menuHeight - 10;
    }
    // ç¡®ä¿ä¸å°äº0
    left = Math.max(10, left);
    top = Math.max(10, top);
    
    menu.style.left = left + 'px';
    menu.style.top = top + 'px';
}

function closeMenu() { document.getElementById('menu').style.display = 'none'; }

function applyEvent(type) {
    playEffect(type);
    const { r, c } = activePos;
    const mark = (row, col) => {
        if (row >= 0 && row < 7 && col >= 0 && col < 7) {
            const idx = row * 7 + col;
            state.grid[idx] = true;
            document.getElementById(`cell-${idx}`).classList.add('opened');
        }
    };
    if (type === 1) {
        mark(r, c);
        state.currentMisses++;
    } else {
        // ç±»å‹ 2-7
        if (type === 2) for(let i=0; i<7; i++) mark(i, c);
        else if (type === 3) for(let i=0; i<7; i++) mark(r, i);
        else if (type === 4) { for(let i=0; i<7; i++) { mark(i, c); mark(r, i); } }
        else if (type === 5) { mark(r, c); mark(r-1,c); mark(r+1,c); mark(r,c-1); mark(r,c+1); }
        else if (type === 6) { for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) mark(r+i, c+j); }
        else if (type === 7) { state.grid.fill(true); init(); }
        state.currentMisses = 0;
    }

    state.clicks++;
    closeMenu();
    updateAnalysis();
}

// ç®—æ³•å¯¹è±¡
const Algorithms = {
    // è´ªå¿ƒç®—æ³•ï¼šæ ¹æ®ç”¨æˆ·æ¦‚ç‡è‡ªåŠ¨è°ƒæ•´æƒé‡çš„åŠ¨æ€è´ªå¿ƒç®—æ³•
    greedy: function(p, grid) {
        // è®¡ç®—æ¦‚ç‡åˆ†å¸ƒçš„ç‰¹å¾
        const type1Weight = p[0];  // ä»…å½“å‰äº‹ä»¶çš„æ¦‚ç‡
        const colRowWeight = (p[1] + p[2] + p[3]) / 3;  // è¡Œåˆ—ç›¸å…³äº‹ä»¶çš„å¹³å‡æ¦‚ç‡
        const areaWeight = (p[4] + p[5]) / 2;  // åŒºåŸŸç›¸å…³äº‹ä»¶çš„å¹³å‡æ¦‚ç‡
        
        let scores = [];
        for (let i = 0; i < 49; i++) {
            const r = Math.floor(i / 7), c = i % 7;
            if (grid[i]) continue;
            
            // è®¡ç®—å„é¡¹æŒ‡æ ‡
            let rg=0, cg=0, comb=0, cross=0, box=0;
            
            // è®¡ç®—è¡Œæœªå¼€æ•°
            for(let j=0; j<7; j++) {
                if(!grid[r*7+j]) { 
                    rg++; 
                }
            }
            
            // è®¡ç®—åˆ—æœªå¼€æ•°
            for(let j=0; j<7; j++) {
                if(!grid[j*7+c]) { 
                    cg++; 
                }
            }
            
            // è®¡ç®—è¡Œ+åˆ—æœªå¼€æ•°ï¼ˆä¿®æ­£ï¼šå‡å»é‡å¤è®¡ç®—çš„å½“å‰æ ¼å­ï¼‰
            // å½“å‰æ ¼å­(r,c)åœ¨rgå’Œcgä¸­å„è¢«è®¡ç®—äº†ä¸€æ¬¡ï¼Œæ‰€ä»¥éœ€è¦å‡1
            comb = rg + cg - 1;
            
            // è®¡ç®—åå­—æœªå¼€æ•°ï¼ˆåŒ…æ‹¬è‡ªèº«ï¼‰
            [[0,0],[1,0],[-1,0],[0,1],[0,-1]].forEach(o => {
                let nr=r+o[0], nc=c+o[1];
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) cross++;
            });
            
            // è®¡ç®—ä¹å®«æ ¼æœªå¼€æ•°
            for(let dr=-1;dr<=1;dr++) {
                for(let dc=-1;dc<=1;dc++){
                    let nr=r+dr, nc=c+dc;
                    if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) box++;
                }
            }
            
            const totalUnopened = grid.filter(v=>!v).length;
            
            // åŠ¨æ€è°ƒæ•´ï¼šæ ¹æ®æ¦‚ç‡é‡è¦æ€§åŠ æƒ
            // å½“æŸç§ç±»å‹æ¦‚ç‡é«˜æ—¶ï¼Œå¢å¼ºå¯¹åº”æŒ‡æ ‡çš„å½±å“
            const dynamicScore = 
                p[0] * 1 * (1.0 + type1Weight * 0.5) +  // ç±»å‹1æ¦‚ç‡é«˜æ—¶ï¼Œæ›´é‡è§†å½“å‰æ ¼å­
                p[1] * cg * (1.0 + colRowWeight * 1.5) +  // è¡Œåˆ—æ¦‚ç‡é«˜æ—¶ï¼Œæ›´é‡è§†åˆ—æœªå¼€æ•°
                p[2] * rg * (1.0 + colRowWeight * 1.5) +  // è¡Œåˆ—æ¦‚ç‡é«˜æ—¶ï¼Œæ›´é‡è§†è¡Œæœªå¼€æ•°
                p[3] * comb * (1.0 + colRowWeight * 2.0) +  // è¡Œ+åˆ—æ¦‚ç‡é«˜æ—¶ï¼Œæ›´é‡è§†comb
                p[4] * cross * (1.0 + areaWeight * 1.2) +  // åŒºåŸŸæ¦‚ç‡é«˜æ—¶ï¼Œå¢å¼ºåå­—å½±å“
                p[5] * box * (1.0 + areaWeight * 1.2) +  // åŒºåŸŸæ¦‚ç‡é«˜æ—¶ï¼Œå¢å¼ºä¹å®«æ ¼å½±å“
                p[6] * totalUnopened * 0.3;  // å…¨å¼€æ¦‚ç‡é€šå¸¸å¾ˆä½ï¼Œæƒé‡é™ä½
            
            scores.push({ i, score: dynamicScore });
        }
        return scores;
    },
    
    // æ”¹è¿›çš„å¸¦æƒå¯å‘å¼ï¼šf(n) = Î±*g(n) + Î²*w*h(n)ï¼Œæ›´å¹³è¡¡çš„æƒé‡è®¾è®¡
    heuristic: function(p, grid, weight) {
        const totalUnopened = grid.filter(v=>!v).length;
        const gamePhase = totalUnopened / 49; // 1=æ—©æœŸï¼Œ0=æœ«æœŸ
        
        let scores = [];
        // è®¡ç®—æ¯ä¸ªæ ¼å­çš„ g(n)ï¼ˆåŸºç¡€æ”¶ç›Šï¼‰
        for (let i = 0; i < 49; i++) {
            const r = Math.floor(i / 7), c = i % 7;
            if (grid[i]) continue;
            
            // --- 1. ç›´æ¥æœŸæœ›æ”¶ç›Š g(n) ---
            let g = 0;
            let rg=0, cg=0, comb=0, cross=0, box=0;
            for(let j=0; j<7; j++) {
                if(!grid[r*7+j]) { rg++; comb++; }
                if(!grid[j*7+c]) { cg++; if(j!==r) comb++; }
            }
            g = p[0]*1 + p[1]*cg + p[2]*rg + p[3]*comb;
            [[0,0],[1,0],[-1,0],[0,1],[0,-1]].forEach(o => {
                let nr=r+o[0], nc=c+o[1];
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) cross++;
            });
            for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
                let nr=r+dr, nc=c+dc;
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) box++;
            }
            g += p[4]*cross + p[5]*box + p[6]*totalUnopened;
            
            // --- 2. æ”¹è¿›çš„å¯å‘å¼å‡½æ•° h(n) ---
            // è€ƒè™‘æ›´å¤šç»´åº¦çš„æ½œåŠ›è¯„ä¼°
            
            // a) å±€éƒ¨å¯†åº¦ï¼ˆ3x3åŒºåŸŸï¼‰
            let h_local = 0;
            for(let dr=-1;dr<=1;dr++) {
                for(let dc=-1;dc<=1;dc++) {
                    let nr=r+dr, nc=c+dc;
                    if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) {
                        h_local++;
                    }
                }
            }
            
            // b) è¡Œåˆ—æ½œåŠ›
            let row_unopened = 0;
            let col_unopened = 0;
            for(let j=0; j<7; j++) {
                if(!grid[r*7+j]) row_unopened++;
                if(!grid[j*7+c]) col_unopened++;
            }
            
            // c) ä½ç½®ä»·å€¼ï¼ˆä¸­å¿ƒä½ç½®æ›´å¥½ï¼‰
            const centerDist = Math.abs(r-3) + Math.abs(c-3);
            const positionValue = 1.0 - (centerDist / 12); // 0-1ï¼Œä¸­å¿ƒä¸º1
            
            // d) å­¤ç«‹åº¦è¯„ä¼°ï¼ˆé‚»å±…è¶Šå°‘è¶Šå­¤ç«‹ï¼‰
            let neighborCount = 0;
            for(let dr=-1;dr<=1;dr++) {
                for(let dc=-1;dc<=1;dc++) {
                    if(dr===0 && dc===0) continue;
                    let nr=r+dr, nc=c+dc;
                    if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) {
                        neighborCount++;
                    }
                }
            }
            const isolation = 1.0 - (neighborCount / 8); // 0-1ï¼Œè¶Šå­¤ç«‹å€¼è¶Šå¤§
            
            // å½’ä¸€åŒ–
            const h_local_norm = h_local / 9;
            const row_norm = row_unopened / 7;
            const col_norm = col_unopened / 7;
            
            // --- 3. åŠ¨æ€æƒé‡åˆ†é… ---
            // æ ¹æ®æ¸¸æˆé˜¶æ®µè°ƒæ•´å„é¡¹çš„é‡è¦æ€§
            
            let h;
            if (gamePhase > 0.6) { // æ—©æœŸï¼ˆ>60%æœªå¼€ï¼‰
                // æ—©æœŸï¼šæ³¨é‡æ¢ç´¢å’Œä½ç½®ä»·å€¼
                h = positionValue * 0.3 + h_local_norm * 0.4 + (row_norm + col_norm) * 0.3;
            } else if (gamePhase > 0.3) { // ä¸­æœŸï¼ˆ30%-60%ï¼‰
                // ä¸­æœŸï¼šå¹³è¡¡å„ç§å› ç´ 
                h = positionValue * 0.2 + h_local_norm * 0.3 + (row_norm + col_norm) * 0.3 + (1 - isolation) * 0.2;
            } else { // åæœŸï¼ˆ<30%ï¼‰
                // åæœŸï¼šä¼˜å…ˆæ¸…ç†å­¤ç«‹æ ¼å­
                h = (1 - isolation) * 0.5 + h_local_norm * 0.2 + (row_norm + col_norm) * 0.3;
            }
            
            // --- 4. æ”¹è¿›çš„æƒé‡è°ƒæ•´ ---
            // ä¸å†è¿‡åº¦è¡°å‡æƒé‡ï¼Œè€Œæ˜¯æ ¹æ®é˜¶æ®µå’Œæ¦‚ç‡åŠ¨æ€è°ƒæ•´
            
            // é«˜æ•ˆäº‹ä»¶çš„æ€»æ¦‚ç‡
            const efficiencyProb = p[1] + p[2] + p[3] + p[4] + p[5];
            
            // åŠ¨æ€æƒé‡å› å­ï¼š
            // - æ—©æœŸæƒé‡é«˜ï¼ˆæ³¨é‡æ¢ç´¢ï¼‰
            // - é«˜æ•ˆäº‹ä»¶æ¦‚ç‡é«˜æ—¶æƒé‡é«˜ï¼ˆæ½œåŠ›æ›´é‡è¦ï¼‰
            // - åŸºç¡€æƒé‡ç”±ç”¨æˆ·æ§åˆ¶
            const phaseFactor = 0.5 + gamePhase * 0.5; // æ—©æœŸ1.0ï¼ŒåæœŸ0.5
            const efficiencyFactor = 1.0 + efficiencyProb * 3; // é«˜æ•ˆæ¦‚ç‡é«˜æ—¶æ”¾å¤§
            
            const effectiveWeight = weight * phaseFactor * efficiencyFactor;
            
            // --- 5. å¹³è¡¡çš„åˆ†æ•°è®¡ç®— ---
            // ç¡®ä¿gå’Œhéƒ¨åˆ†æœ‰åˆç†çš„æ¯”ä¾‹
            // gå€¼èŒƒå›´å¤§çº¦åœ¨10-100ï¼Œhå€¼èŒƒå›´0-1
            
            // æ ‡å‡†åŒ–gå€¼åˆ°0-1èŒƒå›´ï¼ˆä¼°è®¡æœ€å¤§gå€¼çº¦120ï¼‰
            const g_normalized = Math.min(g / 120, 1.0);
            
            // ç»¼åˆåˆ†æ•°ï¼šå¹³è¡¡ç›´æ¥æ”¶ç›Šå’Œæ½œåŠ›
            // ä½¿ç”¨åŠ æƒå¹³å‡ï¼Œè€Œä¸æ˜¯ç®€å•ç›¸åŠ 
            const alpha = 0.7 - 0.3 * gamePhase; // æ—©æœŸ0.4ï¼ŒåæœŸ0.7ï¼ˆæ›´æ³¨é‡ç›´æ¥æ”¶ç›Šï¼‰
            const beta = 1 - alpha;
            
            const f = (g_normalized * alpha + h * beta) * 100 * (1 + effectiveWeight * 0.5);
            
            scores.push({ i, score: f });
        }
        return scores;
    },
    
    // ç†µå‡ç®—æ³•ï¼šä¼˜å…ˆè®¡ç®—å¹¶æ ‡æ³¨å‘¨å›´é‚»å±…ï¼ˆæœªå¼€å¯ç©ºæ ¼ï¼‰æœ€å°‘çš„å­¤ç«‹æ ¼å­
    entropy: function(p, grid) {
        let scores = [];
        
        // é¦–å…ˆï¼Œè®¡ç®—æ¯ä¸ªæ ¼å­çš„å­¤ç«‹åº¦
        for (let i = 0; i < 49; i++) {
            const r = Math.floor(i / 7), c = i % 7;
            if (grid[i]) continue;
            
            // åŸºç¡€æ”¶ç›Š g(n)
            let g = 0;
            let rg=0, cg=0, comb=0, cross=0, box=0;
            for(let j=0; j<7; j++) {
                if(!grid[r*7+j]) { rg++; comb++; }
                if(!grid[j*7+c]) { cg++; if(j!==r) comb++; }
            }
            g = p[0]*1 + p[1]*cg + p[2]*rg + p[3]*comb;
            [[0,0],[1,0],[-1,0],[0,1],[0,-1]].forEach(o => {
                let nr=r+o[0], nc=c+o[1];
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) cross++;
            });
            for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
                let nr=r+dr, nc=c+dc;
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) box++;
            }
            g += p[4]*cross + p[5]*box + p[6]*(grid.filter(v=>!v).length);
            
            // è®¡ç®—å‘¨å›´æœªå¼€å¯é‚»å±…çš„æ•°é‡ï¼ˆ8è¿é€šï¼ŒåŒ…æ‹¬å¯¹è§’çº¿ï¼‰
            let neighborCount = 0;
            for(let dr=-1;dr<=1;dr++) {
                for(let dc=-1;dc<=1;dc++) {
                    if(dr===0 && dc===0) continue;
                    let nr=r+dr, nc=c+dc;
                    if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) {
                        neighborCount++;
                    }
                }
            }
            
            // è®¡ç®—å­¤ç«‹åº¦ï¼šé‚»å±…è¶Šå°‘ï¼Œå­¤ç«‹åº¦è¶Šé«˜
            // æœ€å¤§é‚»å±…æ•°æ˜¯8
            const isolationScore = (8 - neighborCount) / 8;
            
            // è®¡ç®—åŒºåŸŸå¯†åº¦ï¼šå‘¨å›´3x3åŒºåŸŸå†…æœªå¼€å¯æ ¼å­çš„æ¯”ä¾‹
            let areaUnopened = 0;
            let areaTotal = 0;
            for(let dr=-1;dr<=1;dr++) {
                for(let dc=-1;dc<=1;dc++) {
                    let nr=r+dr, nc=c+dc;
                    if(nr>=0&&nr<7&&nc>=0&&nc<7) {
                        areaTotal++;
                        if(!grid[nr*7+nc]) areaUnopened++;
                    }
                }
            }
            const densityScore = areaUnopened / areaTotal;
            
            // æœ€ç»ˆåˆ†æ•° = åŸºç¡€æ”¶ç›Š + å­¤ç«‹åº¦æƒé‡ + å¯†åº¦æƒé‡
            // è°ƒæ•´æƒé‡ï¼šåœ¨æ¸¸æˆåæœŸï¼Œæ›´æ³¨é‡æ¸…ç†å­¤ç«‹æ ¼å­
            const totalUnopened = grid.filter(v=>!v).length;
            const gamePhase = totalUnopened / 49; // 0-1ï¼Œè¶Šå°è¡¨ç¤ºè¶ŠåæœŸ
            
            // åæœŸæ—¶å¢åŠ å­¤ç«‹åº¦æƒé‡
            const isolationWeight = 80 * (1 - gamePhase);
            const densityWeight = 30 * gamePhase;
            
            const score = g + isolationScore * isolationWeight + densityScore * densityWeight;
            scores.push({ i, score: score });
        }
        return scores;
    },
    
    // ç»¼åˆæ¨èç®—æ³•ï¼šæ ¹æ®é€‰æ‹©çš„ç®—æ³•è®¡ç®—ç»¼åˆåˆ†æ•°
    comprehensive: function(p, grid, heuristicWeight, selectedAlgorithms) {
        let scores = [];
        
        // å¦‚æœæ²¡æœ‰æŒ‡å®šé€‰æ‹©çš„ç®—æ³•ï¼Œä½¿ç”¨é»˜è®¤ï¼ˆå…¨éƒ¨ï¼‰
        if (!selectedAlgorithms) {
            selectedAlgorithms = {
                greedy: true,
                heuristic: true,
                entropy: true,
                mcts: false
            };
        }
        
        // è®¡ç®—é€‰æ‹©çš„ç®—æ³•çš„åˆ†æ•°
        const algorithmScores = [];
        const algorithmMaps = [];
        
        if (selectedAlgorithms.greedy) {
            const greedyScores = this.greedy(p, grid);
            const greedyMap = new Map();
            greedyScores.forEach(s => greedyMap.set(s.i, s.score));
            algorithmMaps.push(greedyMap);
        }
        if (selectedAlgorithms.heuristic) {
            const heuristicScores = this.heuristic(p, grid, heuristicWeight);
            const heuristicMap = new Map();
            heuristicScores.forEach(s => heuristicMap.set(s.i, s.score));
            algorithmMaps.push(heuristicMap);
        }
        if (selectedAlgorithms.entropy) {
            const entropyScores = this.entropy(p, grid);
            const entropyMap = new Map();
            entropyScores.forEach(s => entropyMap.set(s.i, s.score));
            algorithmMaps.push(entropyMap);
        }
        if (selectedAlgorithms.mcts) {
            const mctsScores = this.fastMCTS(p, grid, 50); // ä½¿ç”¨è¾ƒå°‘çš„è¿­ä»£æ¬¡æ•°
            const mctsMap = new Map();
            mctsScores.forEach(s => mctsMap.set(s.i, s.score));
            algorithmMaps.push(mctsMap);
        }
        
        // å¦‚æœæ²¡æœ‰é€‰æ‹©ä»»ä½•ç®—æ³•ï¼Œè¿”å›ç©ºæ•°ç»„
        if (algorithmMaps.length === 0) {
            return [];
        }
        
        // è®¡ç®—æ¯ä¸ªæ ¼å­çš„ç»¼åˆåˆ†æ•°ï¼ˆæ‰€é€‰ç®—æ³•çš„å¹³å‡å€¼ï¼‰
        for (let i = 0; i < 49; i++) {
            if (grid[i]) continue;
            
            let sum = 0;
            let count = 0;
            
            for (const map of algorithmMaps) {
                const score = map.get(i);
                if (score !== undefined) {
                    sum += score;
                    count++;
                }
            }
            
            const combinedScore = count > 0 ? sum / count : 0;
            scores.push({ i, score: combinedScore });
        }
        
        return scores;
    },
    
    // è’™ç‰¹å¡æ´›æ ‘æœç´¢ï¼ˆæ™ºèƒ½ç‰ˆï¼‰
    mcts: function(p, grid, iterations = null) {
        // å¦‚æœæœªæŒ‡å®šè¿­ä»£æ¬¡æ•°ï¼Œä½¿ç”¨é»˜è®¤å€¼
        if (iterations === null) {
            iterations = state.mctsIterations || 300;
        }
        
        // æ ¹æ®æ˜¯å¦å¯ç”¨ç¨³å®šæ€§æ¨¡å¼é€‰æ‹©ç®—æ³•
        if (state.mctsStable !== false) {
            // ç¨³å®šæ€§æ¨¡å¼ï¼šè¿è¡Œå¤šæ¬¡å–å¹³å‡
            const effectiveIterations = Math.max(iterations, 150);
            const results = [];
            const runCount = 3; // è¿è¡Œ3æ¬¡å–å¹³å‡
            
            for (let run = 0; run < runCount; run++) {
                const runResult = this.fastMCTS(p, grid, Math.floor(effectiveIterations / runCount));
                results.push(runResult);
            }
            
            // è®¡ç®—å¹³å‡åˆ†æ•°
            const avgScores = Array(49).fill(0);
            const scoreCounts = Array(49).fill(0);
            
            for (const runResult of results) {
                for (const item of runResult) {
                    avgScores[item.i] += item.score;
                    scoreCounts[item.i]++;
                }
            }
            
            // æ„å»ºæœ€ç»ˆç»“æœ
            const finalResult = [];
            for (let i = 0; i < 49; i++) {
                if (!grid[i] && scoreCounts[i] > 0) {
                    finalResult.push({
                        i,
                        score: avgScores[i] / scoreCounts[i]
                    });
                }
            }
            
            // å¦‚æœæ²¡æœ‰ç»“æœï¼Œè¿”å›é»˜è®¤
            if (finalResult.length === 0) {
                return this.fastMCTS(p, grid, effectiveIterations);
            }
            
            return finalResult;
        } else {
            // æ™®é€šæ¨¡å¼ï¼šå•æ¬¡è¿è¡Œ
            return this.fastMCTS(p, grid, iterations);
        }
    },
    
    // å¿«é€Ÿè’™ç‰¹å¡æ´›æœç´¢
    fastMCTS: function(p, grid, iterations = 200) {
        const scores = Array(49).fill(0);
        const visits = Array(49).fill(0);
        
        // è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®æ¦‚ç‡é€‰æ‹©äº‹ä»¶ç±»å‹
        const chooseEventByProbability = (probs) => {
            const rand = Math.random() * 100;
            let accum = 0;
            for (let i = 0; i < 7; i++) {
                accum += probs[i];
                if (rand <= accum) return i + 1;
            }
            return 7;
        };
        
        // è¾…åŠ©å‡½æ•°ï¼šåº”ç”¨äº‹ä»¶åˆ°ç½‘æ ¼
        const applyEventToGrid = (type, idx, currentGrid) => {
            const r = Math.floor(idx / 7), c = idx % 7;
            const mark = (row, col) => {
                if (row >= 0 && row < 7 && col >= 0 && col < 7) {
                    currentGrid[row * 7 + col] = true;
                }
            };
            
            if (type === 1) {
                mark(r, c);
            } else if (type === 2) {
                for (let i = 0; i < 7; i++) mark(i, c);
            } else if (type === 3) {
                for (let i = 0; i < 7; i++) mark(r, i);
            } else if (type === 4) {
                for (let i = 0; i < 7; i++) { mark(i, c); mark(r, i); }
            } else if (type === 5) {
                mark(r, c); 
                if (r-1 >= 0) mark(r-1, c);
                if (r+1 < 7) mark(r+1, c);
                if (c-1 >= 0) mark(r, c-1);
                if (c+1 < 7) mark(r, c+1);
            } else if (type === 6) {
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        mark(r+i, c+j);
                    }
                }
            } else if (type === 7) {
                for (let i = 0; i < 49; i++) currentGrid[i] = true;
            }
        };
        
        // å¿«é€Ÿæ¨¡æ‹Ÿå‡½æ•°
        const fastSimulate = (startGrid, firstAction) => {
            let grid = [...startGrid];
            let steps = 0;
            
            // ç¬¬ä¸€æ­¥ä½¿ç”¨æŒ‡å®šçš„è¡ŒåŠ¨
            if (firstAction !== null) {
                const eventType = chooseEventByProbability(p.map(prob => prob * 100));
                applyEventToGrid(eventType, firstAction, grid);
                steps++;
            }
            
            // åç»­æ­¥éª¤éšæœºé€‰æ‹©ï¼Œæœ€å¤šæ¨¡æ‹Ÿ10æ­¥
            while (steps < 10 && grid.some(cell => !cell)) {
                const unopened = [];
                for (let i = 0; i < 49; i++) {
                    if (!grid[i]) unopened.push(i);
                }
                if (unopened.length === 0) break;
                
                const randomAction = unopened[Math.floor(Math.random() * unopened.length)];
                const eventType = chooseEventByProbability(p.map(prob => prob * 100));
                applyEventToGrid(eventType, randomAction, grid);
                steps++;
            }
            
            // å¥–åŠ±ï¼šå¼€å¯çš„æ ¼å­æ•°è¶Šå¤šè¶Šå¥½ï¼Œæ­¥æ•°è¶Šå°‘è¶Šå¥½
            const opened = grid.filter(cell => cell).length;
            return opened * 2 - steps;
        };
        
        // è¿è¡Œå¤šæ¬¡æ¨¡æ‹Ÿ
        for (let iter = 0; iter < iterations; iter++) {
            // å¯¹æ¯ä¸ªæœªå¼€å¯çš„æ ¼å­è¿›è¡Œé‡‡æ ·
            for (let i = 0; i < 49; i++) {
                if (!grid[i]) {
                    const reward = fastSimulate(grid, i);
                    scores[i] += reward;
                    visits[i]++;
                }
            }
        }
        
        // è®¡ç®—å¹³å‡åˆ†æ•°
        const result = [];
        for (let i = 0; i < 49; i++) {
            if (!grid[i] && visits[i] > 0) {
                result.push({ 
                    i, 
                    score: scores[i] / visits[i] 
                });
            }
        }
        
        // å¦‚æœæ²¡æœ‰ç»“æœï¼Œè¿”å›ç©ºæ•°ç»„
        if (result.length === 0) {
            // è¿”å›æ‰€æœ‰æœªå¼€å¯æ ¼å­çš„é»˜è®¤åˆ†æ•°
            for (let i = 0; i < 49; i++) {
                if (!grid[i]) {
                    result.push({ i, score: 50 });
                }
            }
        }
        
        return result;
    }
};

// çº¯éšæœºæ¨¡æ‹Ÿï¼šæ¯æ¬¡éšæœºé€‰æ‹©ä¸€ä¸ªæœªå¼€å¯çš„æ ¼å­
function runRandomSimulation(iterations = 1000) {
    // å¤åˆ¶å½“å‰çŠ¶æ€è®¾ç½®
    const baseProbs = [...state.probs];
    const enablePity = state.enablePity;
    const pityStart = state.pityStart;
    const pityMax = state.pityMax;
    
    // æ¨¡æ‹Ÿå‡½æ•°
    function simulateOneRandomGame() {
        let grid = Array(49).fill(false);
        let clicks = 0;
        let currentMisses = 0;
        
        // è¾…åŠ©å‡½æ•°ï¼šåº”ç”¨äº‹ä»¶
        const applyEventToGrid = (type, r, c, grid) => {
            const mark = (row, col) => {
                if (row >= 0 && row < 7 && col >= 0 && col < 7) {
                    const idx = row * 7 + col;
                    grid[idx] = true;
                }
            };
            if (type === 1) {
                mark(r, c);
                currentMisses++;
            } else {
                if (type === 2) for(let i=0; i<7; i++) mark(i, c);
                else if (type === 3) for(let i=0; i<7; i++) mark(r, i);
                else if (type === 4) { for(let i=0; i<7; i++) { mark(i, c); mark(r, i); } }
                else if (type === 5) { mark(r, c); mark(r-1,c); mark(r+1,c); mark(r,c-1); mark(r,c+1); }
                else if (type === 6) { for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) mark(r+i, c+j); }
                else if (type === 7) { grid.fill(true); }
                currentMisses = 0;
            }
            return grid;
        };
        
        // é€‰æ‹©äº‹ä»¶ç±»å‹ï¼ˆè€ƒè™‘ä¿åº•ï¼‰
        const chooseEventType = () => {
            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å¤§ä¿åº•æ¬¡æ•°ï¼Œå¦‚æœæ˜¯åˆ™å¿…è§¦å‘éç±»å‹1äº‹ä»¶
            if (enablePity && currentMisses >= pityMax) {
                // å¿…è§¦å‘éç±»å‹1äº‹ä»¶ï¼ˆ2-7ï¼‰
                // éšæœºé€‰æ‹©2-7ä¸­çš„ä¸€ç§ï¼ŒæŒ‰åŸå§‹æ¦‚ç‡æ¯”ä¾‹
                const nonType1Probs = baseProbs.slice(1); // è·å–ç±»å‹2-7çš„æ¦‚ç‡
                const totalNonType1 = nonType1Probs.reduce((a, b) => a + b, 0);
                const normalizedNonType1 = nonType1Probs.map(p => p / totalNonType1);
                
                const rand = Math.random();
                let accum = 0;
                for (let i = 0; i < 6; i++) {
                    accum += normalizedNonType1[i];
                    if (rand <= accum) return i + 2; // è¿”å›2-7
                }
                return 7; // é»˜è®¤
            }
            
            // åŠ¨æ€æ¦‚ç‡è°ƒæ•´
            let adjustedProbs = [...baseProbs];
            if (enablePity && currentMisses >= pityStart) {
                const progress = Math.min((currentMisses - pityStart + 1) / (pityMax - pityStart + 1), 1.0);
                // é€æ­¥å¢åŠ éç±»å‹1äº‹ä»¶çš„æ¦‚ç‡
                // ç±»å‹1çš„æ¦‚ç‡å‡å°‘ï¼Œå…¶ä»–ç±»å‹çš„æ¦‚ç‡æŒ‰æ¯”ä¾‹å¢åŠ 
                const type1Reduction = 0.5 * progress; // æœ€å¤šå‡å°‘50%
                adjustedProbs[0] = baseProbs[0] * (1 - type1Reduction);
                
                // å°†å‡å°‘çš„æ¦‚ç‡åˆ†é…åˆ°å…¶ä»–ç±»å‹
                const reductionAmount = baseProbs[0] * type1Reduction;
                const otherTotal = baseProbs.slice(1).reduce((a, b) => a + b, 0);
                
                for (let i = 1; i < 7; i++) {
                    adjustedProbs[i] = baseProbs[i] + (reductionAmount * (baseProbs[i] / otherTotal));
                }
            }
            
            // å½’ä¸€åŒ–
            const sum = adjustedProbs.reduce((a, b) => a + b, 0);
            const normalized = adjustedProbs.map(p => p / sum);
            
            // éšæœºé€‰æ‹©
            const rand = Math.random();
            let accum = 0;
            for (let i = 0; i < 7; i++) {
                accum += normalized[i];
                if (rand <= accum) return i + 1;
            }
            return 7;
        };
        
        // éšæœºé€‰æ‹©ä¸€ä¸ªæœªå¼€å¯çš„æ ¼å­
        const chooseRandomCell = (grid) => {
            // æ”¶é›†æ‰€æœ‰æœªå¼€å¯æ ¼å­çš„ç´¢å¼•
            const unopenedIndices = [];
            for (let i = 0; i < 49; i++) {
                if (!grid[i]) unopenedIndices.push(i);
            }
            if (unopenedIndices.length === 0) return null;
            
            // éšæœºé€‰æ‹©ä¸€ä¸ª
            const randomIndex = Math.floor(Math.random() * unopenedIndices.length);
            const idx = unopenedIndices[randomIndex];
            return { r: Math.floor(idx / 7), c: idx % 7 };
        };
        
        // ä¸»å¾ªç¯
        while (grid.some(cell => !cell)) {
            const randomCell = chooseRandomCell(grid);
            if (!randomCell) break;
            const eventType = chooseEventType();
            applyEventToGrid(eventType, randomCell.r, randomCell.c, grid);
            clicks++;
        }
        return clicks;
    }
    
    // è¿è¡Œå¤šæ¬¡æ¨¡æ‹Ÿ
    const results = [];
    for (let i = 0; i < iterations; i++) {
        results.push(simulateOneRandomGame());
    }
    return results;
}

// æ¨¡æ‹Ÿå•ä¸ªæ¸¸æˆç›´åˆ°å®Œæˆï¼Œè¿”å›ç‚¹å‡»æ¬¡æ•°
function runSimulation(algorithmType, iterations = 1000) {
    // å¤åˆ¶å½“å‰çŠ¶æ€è®¾ç½®
    const baseProbs = [...state.probs];
    const enablePity = state.enablePity;
    const pityStart = state.pityStart;
    const pityMax = state.pityMax;
    const heuristicWeight = state.heuristicWeight;
    
    // æ¨¡æ‹Ÿå‡½æ•°
    function simulateOneGame() {
        let grid = Array(49).fill(false);
        let clicks = 0;
        let currentMisses = 0;
        
        // è¾…åŠ©å‡½æ•°ï¼šåº”ç”¨äº‹ä»¶
        const applyEventToGrid = (type, r, c, grid) => {
            const mark = (row, col) => {
                if (row >= 0 && row < 7 && col >= 0 && col < 7) {
                    const idx = row * 7 + col;
                    grid[idx] = true;
                }
            };
            if (type === 1) {
                mark(r, c);
                currentMisses++;
            } else {
                if (type === 2) for(let i=0; i<7; i++) mark(i, c);
                else if (type === 3) for(let i=0; i<7; i++) mark(r, i);
                else if (type === 4) { for(let i=0; i<7; i++) { mark(i, c); mark(r, i); } }
                else if (type === 5) { mark(r, c); mark(r-1,c); mark(r+1,c); mark(r,c-1); mark(r,c+1); }
                else if (type === 6) { for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) mark(r+i, c+j); }
                else if (type === 7) { grid.fill(true); }
                currentMisses = 0;
            }
            return grid;
        };
        
        // é€‰æ‹©äº‹ä»¶ç±»å‹ï¼ˆè€ƒè™‘ä¿åº•ï¼‰
        const chooseEventType = () => {
            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å¤§ä¿åº•æ¬¡æ•°ï¼Œå¦‚æœæ˜¯åˆ™å¿…è§¦å‘éç±»å‹1äº‹ä»¶
            if (enablePity && currentMisses >= pityMax) {
                // å¿…è§¦å‘éç±»å‹1äº‹ä»¶ï¼ˆ2-7ï¼‰
                // éšæœºé€‰æ‹©2-7ä¸­çš„ä¸€ç§ï¼ŒæŒ‰åŸå§‹æ¦‚ç‡æ¯”ä¾‹
                const nonType1Probs = baseProbs.slice(1); // è·å–ç±»å‹2-7çš„æ¦‚ç‡
                const totalNonType1 = nonType1Probs.reduce((a, b) => a + b, 0);
                const normalizedNonType1 = nonType1Probs.map(p => p / totalNonType1);
                
                const rand = Math.random();
                let accum = 0;
                for (let i = 0; i < 6; i++) {
                    accum += normalizedNonType1[i];
                    if (rand <= accum) return i + 2; // è¿”å›2-7
                }
                return 7; // é»˜è®¤
            }
            
            // åŠ¨æ€æ¦‚ç‡è°ƒæ•´
            let adjustedProbs = [...baseProbs];
            if (enablePity && currentMisses >= pityStart) {
                const progress = Math.min((currentMisses - pityStart + 1) / (pityMax - pityStart + 1), 1.0);
                // é€æ­¥å¢åŠ éç±»å‹1äº‹ä»¶çš„æ¦‚ç‡
                // ç±»å‹1çš„æ¦‚ç‡å‡å°‘ï¼Œå…¶ä»–ç±»å‹çš„æ¦‚ç‡æŒ‰æ¯”ä¾‹å¢åŠ 
                const type1Reduction = 0.5 * progress; // æœ€å¤šå‡å°‘50%
                adjustedProbs[0] = baseProbs[0] * (1 - type1Reduction);
                
                // å°†å‡å°‘çš„æ¦‚ç‡åˆ†é…åˆ°å…¶ä»–ç±»å‹
                const reductionAmount = baseProbs[0] * type1Reduction;
                const otherTotal = baseProbs.slice(1).reduce((a, b) => a + b, 0);
                
                for (let i = 1; i < 7; i++) {
                    adjustedProbs[i] = baseProbs[i] + (reductionAmount * (baseProbs[i] / otherTotal));
                }
            }
            
            // å½’ä¸€åŒ–
            const sum = adjustedProbs.reduce((a, b) => a + b, 0);
            const normalized = adjustedProbs.map(p => p / sum);
            
            // éšæœºé€‰æ‹©
            const rand = Math.random();
            let accum = 0;
            for (let i = 0; i < 7; i++) {
                accum += normalized[i];
                if (rand <= accum) return i + 1;
            }
            return 7;
        };
        
        // é€‰æ‹©æœ€ä½³æ ¼å­
        const chooseBestCell = (grid, algorithmType) => {
            // åŠ¨æ€æ¦‚ç‡è°ƒæ•´ï¼ˆç”¨äºè®¡ç®—åˆ†æ•°ï¼Œä¸chooseEventTypeä¸€è‡´ï¼‰
            let adjustedProbs = [...baseProbs];
            if (enablePity && currentMisses >= pityStart) {
                const progress = Math.min((currentMisses - pityStart + 1) / (pityMax - pityStart + 1), 1.0);
                
                // å¦‚æœè¾¾åˆ°æœ€å¤§ä¿åº•æ¬¡æ•°ï¼Œç±»å‹1çš„æ¦‚ç‡ä¸º0
                if (currentMisses >= pityMax) {
                    adjustedProbs[0] = 0;
                    // å…¶ä»–ç±»å‹çš„æ¦‚ç‡æŒ‰åŸå§‹æ¯”ä¾‹åˆ†é…
                    const otherTotal = baseProbs.slice(1).reduce((a, b) => a + b, 0);
                    for (let i = 1; i < 7; i++) {
                        adjustedProbs[i] = (baseProbs[i] / otherTotal) * 100;
                    }
                } else {
                    // é€æ­¥è°ƒæ•´æ¦‚ç‡
                    const type1Reduction = 0.5 * progress;
                    adjustedProbs[0] = baseProbs[0] * (1 - type1Reduction);
                    
                    // å°†å‡å°‘çš„æ¦‚ç‡åˆ†é…åˆ°å…¶ä»–ç±»å‹
                    const reductionAmount = baseProbs[0] * type1Reduction;
                    const otherTotal = baseProbs.slice(1).reduce((a, b) => a + b, 0);
                    
                    for (let i = 1; i < 7; i++) {
                        adjustedProbs[i] = baseProbs[i] + (reductionAmount * (baseProbs[i] / otherTotal));
                    }
                }
                
                // ç¡®ä¿æ€»å’Œä¸º100
                const total = adjustedProbs.reduce((a, b) => a + b, 0);
                if (total > 0) {
                    for (let i = 0; i < 7; i++) {
                        adjustedProbs[i] = (adjustedProbs[i] * 100) / total;
                    }
                }
            }
            const p = adjustedProbs.map(v => v / 100);
            
            // å¦‚æœç®—æ³•ç±»å‹æ˜¯'auto'ï¼Œæ ¹æ®å½“å‰æœªå¼€å¯æ ¼å­æ•°åŠ¨æ€é€‰æ‹©ç®—æ³•
            let actualAlgorithm = algorithmType;
            if (algorithmType === 'auto') {
                // è®¡ç®—æœªå¼€å¯æ ¼å­æ•°
                let unopened = 0;
                for (let i = 0; i < 49; i++) {
                    if (!grid[i]) unopened++;
                }
                // ä½¿ç”¨å¸¦æ»åçš„é˜¶æ®µåˆ¤æ–­
                let stageForSim;
                if (unopened > 37) {
                    stageForSim = "å‰æœŸ";
                } else if (unopened > 35 && window.lastStage === "å‰æœŸ") {
                    stageForSim = "å‰æœŸ";
                } else if (unopened >= 17) {
                    stageForSim = "ä¸­æœŸ";
                } else if (unopened >= 15 && window.lastStage === "ä¸­æœŸ") {
                    stageForSim = "ä¸­æœŸ";
                } else if (unopened >= 13) {
                    stageForSim = "åæœŸ";
                } else {
                    stageForSim = "æœ«æœŸ";
                }
                
                if (stageForSim === "å‰æœŸ") {
                    actualAlgorithm = 'heuristic';
                } else if (stageForSim === "ä¸­æœŸ") {
                    actualAlgorithm = 'greedy';
                } else {
                    actualAlgorithm = 'entropy';
                }
            }
            
            let scores;
            if (actualAlgorithm === 'greedy') {
                scores = Algorithms.greedy(p, grid);
            } else if (actualAlgorithm === 'heuristic') {
                scores = Algorithms.heuristic(p, grid, heuristicWeight);
            } else if (actualAlgorithm === 'entropy') {
                scores = Algorithms.entropy(p, grid);
            } else if (actualAlgorithm === 'comprehensive') {
                scores = Algorithms.comprehensive(p, grid, heuristicWeight, state.comprehensiveAlgorithms);
            } else {
                scores = Algorithms.greedy(p, grid);
            }
            
            // æ‰¾åˆ°æœ€é«˜åˆ†
            if (scores.length === 0) return null;
            let maxScore = -Infinity;
            // æ”¶é›†æ‰€æœ‰æœ€é«˜åˆ†çš„æ ¼å­ç´¢å¼•
            let bestIndices = [];
            for (const s of scores) {
                if (s.score > maxScore) {
                    maxScore = s.score;
                    bestIndices = [s.i];
                } else if (s.score === maxScore) {
                    bestIndices.push(s.i);
                }
            }
            if (bestIndices.length === 0) return null;
            // éšæœºé€‰æ‹©ä¸€ä¸ªæœ€é«˜åˆ†æ ¼å­
            const randomIndex = Math.floor(Math.random() * bestIndices.length);
            const bestIdx = bestIndices[randomIndex];
            return { r: Math.floor(bestIdx / 7), c: bestIdx % 7 };
        };
        
        // ä¸»å¾ªç¯
        while (grid.some(cell => !cell)) {
            const best = chooseBestCell(grid, algorithmType);
            if (!best) break;
            const eventType = chooseEventType();
            applyEventToGrid(eventType, best.r, best.c, grid);
            clicks++;
        }
        return clicks;
    }
    
    // è¿è¡Œå¤šæ¬¡æ¨¡æ‹Ÿ
    const results = [];
    for (let i = 0; i < iterations; i++) {
        results.push(simulateOneGame());
    }
    return results;
}

function updateAnalysis() {
    let unopened = 0;
    let scores = [];
    
    // ç»Ÿè®¡æœªå¼€å¯æ ¼å­æ•°é‡
    for (let i = 0; i < 49; i++) {
        if (!state.grid[i]) unopened++;
    }
    
    // åˆ¤æ–­é˜¶æ®µå¹¶ç¡®å®šæ¨èç®—æ³•ï¼ˆåŸºäºå®é™…è¡¨ç°ä¼˜åŒ–ï¼‰
    let stage, recommendedAlgorithm;
    
    // ä¸Šæ¬¡é˜¶æ®µè®°å½•
    if (!window.lastStage) window.lastStage = '';
    
    // æ ¹æ®æœªå¼€å¯æ ¼å­æ•°åˆ¤æ–­é˜¶æ®µï¼ˆä¼˜åŒ–åçš„é˜ˆå€¼ï¼‰
    // å‰æœŸï¼šå¤§é‡æœªå¼€å¯æ ¼å­ï¼Œéœ€è¦æ¢ç´¢
    if (unopened > 30) { // é™ä½é˜ˆå€¼ï¼Œè®©å¯å‘å¼ç®—æ³•æ›´æ—©ä»‹å…¥
        stage = "å‰æœŸ";
        recommendedAlgorithm = "heuristic";
    } 
    // ä¸­æœŸï¼šä¸­ç­‰æ•°é‡æ ¼å­ï¼Œå¹³è¡¡æ¢ç´¢ä¸åˆ©ç”¨
    else if (unopened >= 10) {
        stage = "ä¸­æœŸ";
        // åœ¨ä¸­æœŸï¼Œæ ¹æ®æ ¼å­åˆ†å¸ƒå†³å®šä½¿ç”¨è´ªå¿ƒè¿˜æ˜¯å¯å‘å¼
        // è®¡ç®—å­¤ç«‹æ ¼å­æ•°é‡
        let isolatedCount = 0;
        for (let i = 0; i < 49; i++) {
            if (state.grid[i]) continue;
            const r = Math.floor(i / 7), c = i % 7;
            let neighborCount = 0;
            for(let dr=-1;dr<=1;dr++) {
                for(let dc=-1;dc<=1;dc++) {
                    if(dr===0 && dc===0) continue;
                    let nr=r+dr, nc=c+dc;
                    if(nr>=0&&nr<7&&nc>=0&&nc<7 && !state.grid[nr*7+nc]) {
                        neighborCount++;
                    }
                }
            }
            if (neighborCount <= 2) isolatedCount++;
        }
        // å¦‚æœå­¤ç«‹æ ¼å­è¾ƒå¤šï¼Œä½¿ç”¨ç†µå‡ç®—æ³•
        if (isolatedCount > unopened * 0.3) {
            recommendedAlgorithm = "entropy";
        } else {
            recommendedAlgorithm = "greedy";
        }
    } 
    // åæœŸï¼šå°‘é‡æ ¼å­ï¼Œä¼˜å…ˆæ¸…ç†å­¤ç«‹æ ¼å­
    else {
        stage = "åæœŸ";
        recommendedAlgorithm = "entropy";
    }
    
    // è®°å½•æœ¬æ¬¡é˜¶æ®µ
    window.lastStage = stage;
    
    // åŠ¨æ€è°ƒæ•´å¯å‘å¼æƒé‡ï¼šå‰æœŸæƒé‡è¾ƒé«˜ï¼ŒåæœŸé™ä½
    if (state.autoWeight && state.currentAlgorithm === 'heuristic') {
        if (stage === "å‰æœŸ") {
            // å‰æœŸï¼šæ¢ç´¢æ›´é‡è¦ï¼Œæƒé‡è¾ƒé«˜ï¼ˆ1.5-2.0ï¼‰
            state.heuristicWeight = Math.max(1.5, Math.min(2.0, 
                state.heuristicWeight || 1.5
            ));
        } else if (stage === "ä¸­æœŸ") {
            // ä¸­æœŸï¼šå¹³è¡¡æ¢ç´¢ä¸åˆ©ç”¨ï¼ˆ1.0-1.5ï¼‰
            state.heuristicWeight = Math.max(1.0, Math.min(1.5,
                state.heuristicWeight || 1.0
            ));
        } else {
            // åæœŸï¼šæ›´æ³¨é‡åˆ©ç”¨ï¼ˆ0.5-1.0ï¼‰
            state.heuristicWeight = Math.max(0.5, Math.min(1.0,
                state.heuristicWeight || 0.8
            ));
        }
    }
    
    // æ›´æ–°æƒé‡è¾“å…¥æ¡†æ˜¾ç¤º
    const weightInput = document.getElementById('heuristicWeight');
    if (weightInput) {
        weightInput.value = state.heuristicWeight.toFixed(1);
        // å¦‚æœè‡ªåŠ¨è°ƒæ•´å¼€å¯ï¼Œå°†è¾“å…¥æ¡†è®¾ä¸ºåªè¯»
        if (state.autoWeight && state.currentAlgorithm === 'heuristic') {
            weightInput.readOnly = true;
            weightInput.style.backgroundColor = '#f0f0f0';
        } else {
            weightInput.readOnly = false;
            weightInput.style.backgroundColor = 'white';
        }
    }
    
    // å¤„ç†ç®—æ³•é€‰æ‹©é€»è¾‘
    let currentAlgorithm = state.currentAlgorithm;
    const algorithmSelect = document.getElementById('algorithmSelect');
    
    // ä¸å†æœ‰åŠ¨æ€åˆ‡æ¢é€»è¾‘
    // ç¡®ä¿å½“å‰ç®—æ³•ä¸æ˜¯'auto'
    if (currentAlgorithm === 'auto') {
        currentAlgorithm = 'comprehensive';
        algorithmSelect.value = 'comprehensive';
    }
    
    // åŠ¨æ€æ¦‚ç‡è°ƒæ•´ï¼ˆä¸æ¨¡æ‹Ÿä¸­çš„é€»è¾‘ä¸€è‡´ï¼‰
    let adjustedProbs = [...state.probs];
    if (state.enablePity && state.currentMisses >= state.pityStart) {
        const progress = Math.min((state.currentMisses - state.pityStart + 1) / (state.pityMax - state.pityStart + 1), 1.0);
        
        // å¦‚æœè¾¾åˆ°æœ€å¤§ä¿åº•æ¬¡æ•°ï¼Œç±»å‹1çš„æ¦‚ç‡ä¸º0ï¼Œå…¶ä»–ç±»å‹æ¦‚ç‡æŒ‰æ¯”ä¾‹å¢åŠ 
        if (state.currentMisses >= state.pityMax) {
            adjustedProbs[0] = 0;
            // å…¶ä»–ç±»å‹çš„æ¦‚ç‡æŒ‰åŸå§‹æ¯”ä¾‹åˆ†é…
            const otherTotal = state.probs.slice(1).reduce((a, b) => a + b, 0);
            for (let i = 1; i < 7; i++) {
                adjustedProbs[i] = (state.probs[i] / otherTotal) * 100;
            }
        } else {
            // é€æ­¥è°ƒæ•´æ¦‚ç‡
            const type1Reduction = 0.5 * progress; // æœ€å¤šå‡å°‘50%
            adjustedProbs[0] = state.probs[0] * (1 - type1Reduction);
            
            // å°†å‡å°‘çš„æ¦‚ç‡åˆ†é…åˆ°å…¶ä»–ç±»å‹
            const reductionAmount = state.probs[0] * type1Reduction;
            const otherTotal = state.probs.slice(1).reduce((a, b) => a + b, 0);
            
            for (let i = 1; i < 7; i++) {
                adjustedProbs[i] = state.probs[i] + (reductionAmount * (state.probs[i] / otherTotal));
            }
        }
        
        // ç¡®ä¿æ€»å’Œä¸º100
        const total = adjustedProbs.reduce((a, b) => a + b, 0);
        if (total > 0) {
            for (let i = 0; i < 7; i++) {
                adjustedProbs[i] = (adjustedProbs[i] * 100) / total;
            }
        }
    }
    
    const p = adjustedProbs.map(v => v / 100);
    const totalP = state.probs.reduce((a, b) => a + b, 0);
    const warningEl = document.getElementById('probWarning');
    warningEl.innerText = `å½“å‰æ€»æƒé‡: ${totalP}% | æœªè§¦å‘è®¡æ•°: ${state.currentMisses}`;
    warningEl.style.color = totalP === 100 ? 'var(--primary)' : 'var(--danger)';
    
    // æ›´æ–°æ˜¾ç¤º
    document.getElementById('currentMissesDisplay').textContent = state.currentMisses;

    // è®¡ç®—æ‰€æœ‰ç®—æ³•çš„åˆ†æ•°ï¼Œå¹¶ç»Ÿä¸€åˆ°ç›¸åŒçš„æ€»åˆ†å°ºåº¦
    const allScores = {
        greedy: Algorithms.greedy(p, state.grid),
        heuristic: Algorithms.heuristic(p, state.grid, state.heuristicWeight),
        entropy: Algorithms.entropy(p, state.grid),
        comprehensive: Algorithms.comprehensive(p, state.grid, state.heuristicWeight, state.comprehensiveAlgorithms),
        mcts: Algorithms.mcts(p, state.grid, state.mctsIterations),
        fastMCTS: Algorithms.fastMCTS(p, state.grid, Math.min(state.mctsIterations || 200, 100))
    };
    
    // è®¡ç®—æ¯ä¸ªç®—æ³•çš„æ€»åˆ†
    const algorithmTotals = {};
    Object.keys(allScores).forEach(alg => {
        algorithmTotals[alg] = allScores[alg].reduce((sum, s) => sum + s.score, 0);
    });
    
    // æ‰¾åˆ°ç›®æ ‡æ€»åˆ†ï¼šä½¿ç”¨è´ªå¿ƒç®—æ³•çš„æ€»åˆ†ä½œä¸ºåŸºå‡†ï¼ˆå› ä¸ºå®ƒæœ€ç¨³å®šï¼‰
    const targetTotal = algorithmTotals.greedy;
    
    // è°ƒæ•´æ¯ä¸ªç®—æ³•çš„åˆ†æ•°ï¼Œä½¿å®ƒä»¬çš„æ€»åˆ†ä¸ç›®æ ‡æ€»åˆ†ä¸€è‡´
    const normalizedScores = {};
    Object.keys(allScores).forEach(alg => {
        const currentTotal = algorithmTotals[alg];
        const scaleFactor = currentTotal > 0 ? targetTotal / currentTotal : 1;
        
        normalizedScores[alg] = allScores[alg].map(s => ({
            i: s.i,
            score: s.score * scaleFactor
        }));
    });
    
    // ç°åœ¨æ‰€æœ‰ç®—æ³•çš„æ€»åˆ†åº”è¯¥å¤§è‡´ç›¸åŒï¼Œä½†ä¸ºäº†æ›´å¥½çš„æ˜¾ç¤ºï¼Œå¯ä»¥å†è¿›è¡Œä¸€æ¬¡å½’ä¸€åŒ–åˆ°0-100
    // æ”¶é›†æ‰€æœ‰è°ƒæ•´åçš„åˆ†æ•°
    let allNormalizedValues = [];
    Object.values(normalizedScores).forEach(algScores => {
        algScores.forEach(s => allNormalizedValues.push(s.score));
    });
    const minScore = Math.min(...allNormalizedValues);
    const maxScore = Math.max(...allNormalizedValues);
    const range = maxScore - minScore;
    
    // æœ€ç»ˆå½’ä¸€åŒ–åˆ°0-100
    Object.keys(normalizedScores).forEach(alg => {
        normalizedScores[alg] = normalizedScores[alg].map(s => {
            if (range === 0) return { i: s.i, score: 50 };
            const normalizedScore = ((s.score - minScore) / range) * 100;
            return { i: s.i, score: normalizedScore };
        });
    });
    
    // è®¡ç®—ç»¼åˆåˆ†æ•°ï¼šä¸‰ä¸ªç®—æ³•åˆ†æ•°çš„å¹³å‡å€¼
    const combinedScores = [];
    for (let i = 0; i < 49; i++) {
        if (state.grid[i]) continue;
        let sum = 0;
        let count = 0;
        Object.keys(normalizedScores).forEach(alg => {
            const scoreObj = normalizedScores[alg].find(s => s.i === i);
            if (scoreObj) {
                sum += scoreObj.score;
                count++;
            }
        });
        const avgScore = count > 0 ? sum / count : 0;
        combinedScores.push({ i, score: avgScore });
    }
    
    // æ ¹æ®å½“å‰é€‰æ‹©çš„ç®—æ³•å†³å®šæ˜¾ç¤ºå“ªä¸ªåˆ†æ•°
    let displayScores;
    if (currentAlgorithm === 'greedy') {
        displayScores = normalizedScores.greedy;
    } else if (currentAlgorithm === 'heuristic') {
        displayScores = normalizedScores.heuristic;
    } else if (currentAlgorithm === 'entropy') {
        displayScores = normalizedScores.entropy;
    } else if (currentAlgorithm === 'comprehensive') {
        displayScores = normalizedScores.comprehensive;
    } else if (currentAlgorithm === 'mcts') {
        displayScores = normalizedScores.mcts;
    } else if (currentAlgorithm === 'fastMCTS') {
        displayScores = normalizedScores.fastMCTS;
    } else {
        // é»˜è®¤ä½¿ç”¨ç»¼åˆæ¨è
        displayScores = normalizedScores.comprehensive;
    }
    
    // æ›´æ–°ç®—æ³•ä¸‹æ‹‰èœå•çš„å‘¼å¸ç¯ç‰¹æ•ˆ
    algorithmSelect.classList.remove('algorithm-pulse');
    // ä¸å†æœ‰è‡ªåŠ¨åˆ‡æ¢ï¼Œæ‰€ä»¥ä¸éœ€è¦å‘¼å¸ç¯
    
    // æ›´æ–°æ˜¾ç¤º
    for (let i = 0; i < 49; i++) {
        const el = document.getElementById(`cell-${i}`);
        el.classList.remove('best', 'good', 'combined-best');
        if (state.grid[i]) continue;
        
        // æ˜¾ç¤ºå½“å‰ç®—æ³•çš„å½’ä¸€åŒ–åˆ†æ•°
        const scoreObj = displayScores.find(s => s.i === i);
        if (scoreObj) {
            document.getElementById(`s-${i}`).innerText = scoreObj.score.toFixed(1);
        } else {
            document.getElementById(`s-${i}`).innerText = '0';
        }
    }

    // æ ‡è®°æœ€ä½³æ ¼å­ï¼ˆåŸºäºå½“å‰æ˜¾ç¤ºç®—æ³•ï¼‰
    if(displayScores.length > 0){
        const max = Math.max(...displayScores.map(s => s.score));
        // ç¡®ä¿maxæ˜¯æœ‰æ•ˆçš„æ•°å­—
        if (isFinite(max) && max > 0) {
            displayScores.forEach(s => {
                if(s.score === max) {
                    document.getElementById(`cell-${s.i}`).classList.add('best');
                } else if(s.score > max * 0.8) {
                    document.getElementById(`cell-${s.i}`).classList.add('good');
                }
            });
        }
    }
    
    // é¢å¤–æ ‡è®°è¢«å¤šä¸ªç®—æ³•æ¨èçš„æ ¼å­
    // è®¡ç®—æ¯ä¸ªæ ¼å­è¢«æ¨èçš„ç¨‹åº¦ï¼ˆåœ¨å½’ä¸€åŒ–åˆ†æ•°ä¸­æ’åå‰3ï¼‰
    const recommendationCount = Array(49).fill(0);
    Object.keys(normalizedScores).forEach(alg => {
        const algScores = normalizedScores[alg];
        // æŒ‰åˆ†æ•°æ’åº
        const sorted = [...algScores].sort((a, b) => b.score - a.score);
        // å–å‰3å
        const top3 = sorted.slice(0, 3);
        top3.forEach(s => {
            recommendationCount[s.i]++;
        });
    });
    
    // æ ‡è®°è¢«è‡³å°‘2ä¸ªç®—æ³•æ¨èçš„æ ¼å­
    for (let i = 0; i < 49; i++) {
        if (state.grid[i]) continue;
        if (recommendationCount[i] >= 2) {
            document.getElementById(`cell-${i}`).classList.add('combined-best');
        }
    }

    if (unopened === 0 && state.clicks > 0) {
        document.getElementById('winOverlay').style.display = 'flex';
        document.getElementById('winMessage').innerText = `å·²é”å®šå…¨å›¾åæ ‡ï¼æœ¬è½®å…±åé¦ˆ ${state.clicks} æ¬¡ã€‚`;
        localStorage.removeItem(STORAGE_KEY);
    }
    
    // æ›´æ–°çŠ¶æ€æ ï¼Œæ˜¾ç¤ºé˜¶æ®µå’Œç®—æ³•
    const algorithmDisplay = currentAlgorithm;
    let scoreType = ' (å½’ä¸€åŒ–)';
    let mctsNote = '';
    
    // å¦‚æœæ˜¯è’™ç‰¹å¡æ´›ç®—æ³•ï¼Œæ·»åŠ è¯´æ˜
    if (currentAlgorithm === 'mcts' || currentAlgorithm === 'fastMCTS') {
        mctsNote = state.mctsStable ? ' [ç¨³å®šæ¨¡å¼]' : ' [åŠ¨æ€æ¨¡å¼]';
        if (!state.mctsStable) {
            mctsNote += ' - ç»“æœä¼šæœ‰æ­£å¸¸æ³¢åŠ¨';
        }
    }
    
    const statusText = window.innerWidth <= 768 
        ? `å‰©ä½™:${unopened} é˜¶æ®µ:${stage} ç®—æ³•:${algorithmDisplay}${mctsNote}`
        : `å‰©ä½™: ${unopened} | é˜¶æ®µ: ${stage} | ç®—æ³•: ${algorithmDisplay}${mctsNote}${scoreType} | ç‚¹å‡»: ${state.clicks}`;
    document.getElementById('statusBar').innerText = statusText;
    
    // æ·»åŠ è¯´æ˜æ–‡æœ¬
    const hasCombinedBest = document.querySelector('.cell.combined-best');
    if (hasCombinedBest) {
        document.getElementById('statusBar').innerText += ' | ç»¿æ¡†:å¤šç®—æ³•æ¨è';
    }
    saveState();
}

// è®¡ç®—ç»Ÿè®¡ä¿¡æ¯çš„è¾…åŠ©å‡½æ•°
function calcStats(arr) {
    if (arr.length === 0) return { mean: 0, variance: 0, std: 0, min: 0, max: 0 };
    const mean = arr.reduce((a,b) => a + b, 0) / arr.length;
    const variance = arr.reduce((a,b) => a + Math.pow(b - mean, 2), 0) / arr.length;
    const std = Math.sqrt(variance);
    const min = Math.min(...arr);
    const max = Math.max(...arr);
    return { mean, variance, std, min, max };
}

function runBatchSimulation() {
    const iterations = parseInt(document.getElementById('simIterations').value) || 1000;
    
    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    const resultsDiv = document.getElementById('simResults');
    const contentDiv = document.getElementById('simResultsContent');
    resultsDiv.style.display = 'block';
    contentDiv.innerHTML = '<p>æ­£åœ¨è¿è¡Œå¤šç®—æ³•å¯¹æ¯”æ¨¡æ‹Ÿï¼Œè¯·ç¨å€™...</p>';
    
    // ä½¿ç”¨ setTimeout é¿å…é˜»å¡ UI
    setTimeout(() => {
        try {
            // å®šä¹‰è¦æµ‹è¯•çš„ç®—æ³•åˆ—è¡¨å’Œå¯¹åº”çš„æ¨¡æ‹Ÿæ¬¡æ•°
            // è’™ç‰¹å¡æ´›ç®—æ³•éœ€è¦æ›´å¤šè®¡ç®—ï¼Œæ‰€ä»¥å‡å°‘æ¨¡æ‹Ÿæ¬¡æ•°ä½†ä¿æŒè´¨é‡
            const algorithmsToTest = [
                { 
                    id: 'greedy', 
                    name: 'è´ªå¿ƒç®—æ³•',
                    simCount: Math.min(iterations, 1000), // æœ€å¤š1000æ¬¡
                    description: 'å¿«é€Ÿç®€å•ï¼Œé€‚åˆå‰æœŸ'
                },
                { 
                    id: 'heuristic', 
                    name: 'å¸¦æƒå¯å‘',
                    simCount: Math.min(iterations, 1000),
                    description: 'å¹³è¡¡æ¢ç´¢ä¸åˆ©ç”¨'
                },
                { 
                    id: 'entropy', 
                    name: 'ç†µå‡ç®—æ³•',
                    simCount: Math.min(iterations, 1000),
                    description: 'æ¸…ç†å­¤ç«‹æ ¼å­'
                },
                { 
                    id: 'comprehensive', 
                    name: 'ç»¼åˆæ¨è',
                    simCount: Math.min(iterations, 1000),
                    description: 'å¤šç®—æ³•èåˆ'
                },
                { 
                    id: 'mcts', 
                    name: 'è’™ç‰¹å¡æ´›æœç´¢',
                    simCount: Math.min(iterations, 300), // è’™ç‰¹å¡æ´›è®¡ç®—é‡å¤§ï¼Œå‡å°‘æ¬¡æ•°
                    description: 'æ·±åº¦å‰ç»ï¼ˆè®¡ç®—é‡å¤§ï¼‰'
                },
                { 
                    id: 'fastMCTS', 
                    name: 'å¿«é€Ÿè’™ç‰¹å¡æ´›',
                    simCount: Math.min(iterations, 500), // å¿«é€Ÿç‰ˆå¯ä»¥å¤šè·‘ä¸€äº›
                    description: 'å¹³è¡¡æ€§èƒ½ä¸æ•ˆæœ'
                }
            ];
            
            // è¿è¡Œæ‰€æœ‰ç®—æ³•çš„æ¨¡æ‹Ÿ
            const allResults = {};
            const allStats = {};
            const computeTimes = {}; // è®°å½•è®¡ç®—æ—¶é—´
            
            // å…ˆè¿è¡Œçº¯éšæœºç®—æ³•ä½œä¸ºåŸºå‡†
            contentDiv.innerHTML = '<p>æ­£åœ¨è¿è¡Œçº¯éšæœºç®—æ³•åŸºå‡†æµ‹è¯•...</p>';
            const randomStart = performance.now();
            const randomResults = runRandomSimulation(Math.min(iterations, 1000));
            const randomTime = performance.now() - randomStart;
            const randomStats = calcStats(randomResults);
            
            // è¿è¡Œæ¯ä¸ªç®—æ³•çš„æ¨¡æ‹Ÿ
            for (const alg of algorithmsToTest) {
                contentDiv.innerHTML = `<p>æ­£åœ¨æµ‹è¯• ${alg.name} (${alg.simCount}æ¬¡æ¨¡æ‹Ÿ)...</p>`;
                const startTime = performance.now();
                const results = runSimulation(alg.id, alg.simCount);
                const endTime = performance.now();
                
                allResults[alg.id] = results;
                allStats[alg.id] = calcStats(results);
                computeTimes[alg.id] = endTime - startTime;
            }
        
        // ç”Ÿæˆå¤šç®—æ³•å¯¹æ¯”ç»“æœè¡¨æ ¼
        let html = `
            <div style="background:#f8f9fa; padding:10px; border-radius:8px; margin-bottom:10px;">
                <h5 style="margin:0 0 8px 0;">å¤šç®—æ³•æ€§èƒ½å¯¹æ¯”</h5>
                <table style="width:100%; font-size:11px; border-collapse:collapse;">
                    <tr>
                        <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">ç®—æ³•</th>
                        <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">æ¨¡æ‹Ÿæ¬¡æ•°</th>
                        <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">å¹³å‡ç‚¹å‡»</th>
                        <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">æ ‡å‡†å·®</th>
                        <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">æå‡%</th>
                        <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">è®¡ç®—æ—¶é—´</th>
                    </tr>
        `;
        
        // æ‰¾åˆ°æœ€ä½³å¹³å‡ç‚¹å‡»æ¬¡æ•°ï¼ˆæ’é™¤è’™ç‰¹å¡æ´›ï¼Œå› ä¸ºå®ƒä»¬æ¨¡æ‹Ÿæ¬¡æ•°ä¸åŒï¼‰
        let bestMean = Infinity;
        let bestAlgorithm = '';
        for (const alg of algorithmsToTest) {
            const stats = allStats[alg.id];
            // åªæ¯”è¾ƒæ¨¡æ‹Ÿæ¬¡æ•°ç›¸è¿‘çš„ç®—æ³•
            if (alg.simCount >= 800 && stats.mean < bestMean) {
                bestMean = stats.mean;
                bestAlgorithm = alg.id;
            }
        }
        
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼ˆå¯èƒ½è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿæ¬¡æ•°å¤ªå°‘ï¼‰ï¼Œä½¿ç”¨æ‰€æœ‰ç®—æ³•
        if (bestMean === Infinity) {
            for (const alg of algorithmsToTest) {
                const stats = allStats[alg.id];
                if (stats.mean < bestMean) {
                    bestMean = stats.mean;
                    bestAlgorithm = alg.id;
                }
            }
        }
        
        // æ·»åŠ éšæœºç®—æ³•è¡Œ
        const randomImprovement = ((randomStats.mean - bestMean) / randomStats.mean * 100).toFixed(1);
        html += `
            <tr style="background:#f0f0f0;">
                <td style="padding:4px; border-bottom:1px solid #eee;"><b>çº¯éšæœºç®—æ³•</b></td>
                <td style="padding:4px; border-bottom:1px solid #eee;">${Math.min(iterations, 1000)}</td>
                <td style="padding:4px; border-bottom:1px solid #eee;">${randomStats.mean.toFixed(2)}</td>
                <td style="padding:4px; border-bottom:1px solid #eee;">${randomStats.std.toFixed(2)}</td>
                <td style="padding:4px; border-bottom:1px solid #eee;">-</td>
                <td style="padding:4px; border-bottom:1px solid #eee;">${randomTime.toFixed(0)}ms</td>
            </tr>
        `;
        
        // æ·»åŠ æ¯ä¸ªç®—æ³•çš„è¡Œ
        for (const alg of algorithmsToTest) {
            const stats = allStats[alg.id];
            const improvement = ((randomStats.mean - stats.mean) / randomStats.mean * 100).toFixed(1);
            const isBest = alg.id === bestAlgorithm;
            const timePerSim = (computeTimes[alg.id] / alg.simCount).toFixed(2);
            
            html += `
                <tr ${isBest ? 'style="background:#e6f7e6;"' : ''}>
                    <td style="padding:4px; border-bottom:1px solid #eee;">${alg.name}${isBest ? ' ğŸ†' : ''}</td>
                    <td style="padding:4px; border-bottom:1px solid #eee;">${alg.simCount}</td>
                    <td style="padding:4px; border-bottom:1px solid #eee; ${isBest ? 'font-weight:bold;' : ''}">${stats.mean.toFixed(2)}</td>
                    <td style="padding:4px; border-bottom:1px solid #eee;">${stats.std.toFixed(2)}</td>
                    <td style="padding:4px; border-bottom:1px solid #eee; color:${parseFloat(improvement) > 0 ? 'green' : 'red'}">${improvement}%</td>
                    <td style="padding:4px; border-bottom:1px solid #eee; font-size:10px;">${computeTimes[alg.id].toFixed(0)}ms (${timePerSim}ms/æ¬¡)</td>
                </tr>
            `;
        }
        
        html += `
                </table>
                <p style="font-size:10px; color:#666; margin-top:5px;">
                    <b>æ³¨ï¼š</b>ç‚¹å‡»æ¬¡æ•°è¶Šå°‘è¶Šå¥½ã€‚è’™ç‰¹å¡æ´›ç®—æ³•æ¨¡æ‹Ÿæ¬¡æ•°è¾ƒå°‘ï¼ˆè®¡ç®—é‡å¤§ï¼‰ï¼Œä½†æ¯æ¬¡å†³ç­–è´¨é‡æ›´é«˜ã€‚
                    æå‡% = (éšæœºå¹³å‡ - ç®—æ³•å¹³å‡) / éšæœºå¹³å‡ Ã— 100%
                </p>
            </div>
            
            <div style="background:#f8f9fa; padding:10px; border-radius:8px;">
                <h5 style="margin:0 0 8px 0;">ç®—æ³•æ€§èƒ½åˆ†æ</h5>
                <div style="font-size:11px; line-height:1.4;">
                    <p><b>ğŸ“Š æµ‹è¯•è¯´æ˜ï¼š</b></p>
                    <ul style="margin:5px 0; padding-left:15px;">
                        <li><b>è´ªå¿ƒç®—æ³•</b>ï¼šå¿«é€Ÿç®€å•ï¼Œé€‚åˆå‰æœŸå¿«é€Ÿå†³ç­–ï¼ˆè®¡ç®—æœ€å¿«ï¼‰</li>
                        <li><b>å¸¦æƒå¯å‘</b>ï¼šå¹³è¡¡æ¢ç´¢ä¸åˆ©ç”¨ï¼Œé€‚åˆä¸­æœŸï¼ˆè®¡ç®—å¿«ï¼‰</li>
                        <li><b>ç†µå‡ç®—æ³•</b>ï¼šä¼˜å…ˆæ¸…ç†å­¤ç«‹æ ¼å­ï¼Œé€‚åˆåæœŸï¼ˆè®¡ç®—å¿«ï¼‰</li>
                        <li><b>ç»¼åˆæ¨è</b>ï¼šå¤šç®—æ³•èåˆï¼Œç¨³å®šæ€§å¥½ï¼ˆè®¡ç®—ä¸­ç­‰ï¼‰</li>
                        <li><b>è’™ç‰¹å¡æ´›æœç´¢</b>ï¼šå¤šæ­¥æ·±åº¦å‰ç»ï¼Œé€‚åˆå¤æ‚å±€é¢ï¼ˆè®¡ç®—é‡å¤§ï¼Œä½†å†³ç­–è´¨é‡é«˜ï¼‰</li>
                        <li><b>å¿«é€Ÿè’™ç‰¹å¡æ´›</b>ï¼šå¹³è¡¡æ€§èƒ½ä¸æ•ˆæœï¼ˆè®¡ç®—é‡ä¸­ç­‰ï¼‰</li>
                    </ul>
                    <p><b>ğŸ¯ è’™ç‰¹å¡æ´›è¡¨ç°é¢„æœŸï¼š</b></p>
                    <ul style="margin:5px 0; padding-left:15px;">
                        <li><b>å‰æœŸ</b>ï¼ˆæœªå¼€å¯>30ï¼‰ï¼šå¯èƒ½ä¸å¦‚è´ªå¿ƒ/å¯å‘å¼ï¼ˆè®¡ç®—å¼€é”€å¤§ï¼‰</li>
                        <li><b>ä¸­æœŸ</b>ï¼ˆæœªå¼€å¯10-30ï¼‰ï¼šå¼€å§‹å±•ç°ä¼˜åŠ¿ï¼Œå¤šæ­¥å‰ç»æœ‰æ•ˆ</li>
                        <li><b>åæœŸ</b>ï¼ˆæœªå¼€å¯<10ï¼‰ï¼šé€šå¸¸è¡¨ç°æœ€ä½³ï¼Œèƒ½å¤„ç†å¤æ‚å±€é¢</li>
                    </ul>
                    <p style="font-size:10px; color:#666; margin-top:5px;">
                        <b>ğŸ’¡ å»ºè®®ï¼š</b>åœ¨å®é™…æ¸¸æˆä¸­ï¼Œå‰æœŸä½¿ç”¨è´ªå¿ƒ/å¯å‘å¼ï¼Œä¸­åæœŸåˆ‡æ¢åˆ°è’™ç‰¹å¡æ´›æœç´¢ã€‚
                    </p>
                </div>
            </div>
            
            <div style="background:#f8f9fa; padding:10px; border-radius:8px; margin-top:10px;">
                <h5 style="margin:0 0 8px 0;">ğŸ“ˆ æ€§èƒ½-è´¨é‡å¹³è¡¡åˆ†æ</h5>
                <div style="font-size:11px;">
                    <p>è’™ç‰¹å¡æ´›ç®—æ³•çš„æ ¸å¿ƒä¼˜åŠ¿ï¼š<b>å¤šæ­¥å‰ç»</b>å’Œ<b>æ¦‚ç‡ä¼˜åŒ–</b>ã€‚</p>
                    <p>åœ¨æ‰¹é‡æ¨¡æ‹Ÿä¸­ï¼Œæˆ‘ä»¬åšäº†ä»¥ä¸‹å¹³è¡¡ï¼š</p>
                    <ol style="margin:5px 0; padding-left:15px;">
                        <li><b>å‡å°‘æ¨¡æ‹Ÿæ¬¡æ•°</b>ï¼šè’™ç‰¹å¡æ´›300æ¬¡ vs å…¶ä»–ç®—æ³•1000æ¬¡</li>
                        <li><b>ä¿æŒå†³ç­–è´¨é‡</b>ï¼šæ¯æ¬¡å†³ç­–ä½¿ç”¨è¶³å¤Ÿè¿­ä»£ï¼ˆ30-100æ¬¡ï¼‰</li>
                        <li><b>åŠ¨æ€è°ƒæ•´</b>ï¼šæ ¹æ®æœªå¼€å¯æ ¼å­æ•°è°ƒæ•´è®¡ç®—æ·±åº¦</li>
                        <li><b>å…¬å¹³å¯¹æ¯”</b>ï¼šè™½ç„¶æ¬¡æ•°å°‘ï¼Œä½†æ¯æ¬¡å†³ç­–æ›´ç²¾ç¡®</li>
                    </ol>
                    <p style="font-size:10px; color:#666;">
                        è¿™ç§è®¾ç½®ä¸‹ï¼Œè’™ç‰¹å¡æ´›çš„<b>æ¯æ¬¡æ¨¡æ‹Ÿæˆæœ¬æ›´é«˜ä½†è´¨é‡æ›´å¥½</b>ï¼Œæ€»ä½“æ€§èƒ½å¯¹æ¯”ä»ç„¶æœ‰æ„ä¹‰ã€‚
                    </p>
                </div>
            </div>
        `;
        
        contentDiv.innerHTML = html;
        } catch (error) {
            console.error('æ¨¡æ‹Ÿè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error);
            contentDiv.innerHTML = `<p style="color:red;">æ¨¡æ‹Ÿè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: ${error.message}</p>`;
        }
    }, 10);
}

function confirmReset() {
    if(confirm("ç¡®å®šé‡ç½®å—ï¼Ÿ")){
        state = JSON.parse(JSON.stringify(defaultData));
        localStorage.removeItem(STORAGE_KEY);
        document.getElementById('winOverlay').style.display = 'none';
        init();
    }
}
window.onload = init;
</script>
</body>
</html>
