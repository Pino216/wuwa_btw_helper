<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é¸£æ½®Â·è¸æ½®æ¢å†ç®—æ³•åŠ©æ‰‹ ğŸ¤–</title>
    <style>
        :root {
            --bg: #f4f7f6;
            --primary: #2ed573;
            --danger: #ff4757;
            --accent: #1e90ff;
            --card-bg: #ffffff;
            --text-main: #333333;
            --text-sub: #666666;
            --grid-gap: 6px;
        }

        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
            color: var(--text-main);
            min-height: 100vh;
        }

        /* é¡¶éƒ¨æ ‡é¢˜ */
        .header { text-align: center; margin-bottom: 20px; width: 100%; }
        .header h2 { margin: 0; font-size: 24px; letter-spacing: 1px; }

        /* æ ¸å¿ƒå¸ƒå±€ */
        .layout {
            display: flex;
            justify-content: center;
            gap: 30px;
            max-width: 1300px;
            width: 100%;
            transition: all 0.4s ease;
        }

        /* --- é…ç½®é¢æ¿ (å“åº”å¼) --- */
        .config-panel {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
            width: 320px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: sticky;
            top: 20px;
            overflow: visible; /* å…è®¸æŒ‰é’®æ˜¾ç¤ºåœ¨å¤–éƒ¨ */
            z-index: 100;
            flex-shrink: 0;
            /* ç§»é™¤å›ºå®šæœ€å°é«˜åº¦ï¼Œè®©å†…å®¹å†³å®šé«˜åº¦ */
            max-height: 90vh; /* é™åˆ¶æœ€å¤§é«˜åº¦ï¼Œé˜²æ­¢è¿‡é•¿ */
            overflow-y: auto; /* å¦‚æœå†…å®¹è¿‡å¤šï¼Œå¯ä»¥æ»šåŠ¨ */
        }

        .config-content { 
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        /* ç”µè„‘ç«¯æŠ˜å çŠ¶æ€ - åŸºç¡€æ ·å¼ï¼Œä¼šè¢«åª’ä½“æŸ¥è¯¢è¦†ç›– */
        .config-panel.collapsed {
            width: 10px;
            padding: 20px 5px;
            background: #eee;
            min-height: 400px; /* ä¿æŒä¸å±•å¼€æ—¶ç›¸åŒçš„æœ€å°é«˜åº¦ */
        }
        .config-panel.collapsed .config-content { 
            opacity: 0; 
            visibility: hidden; 
            pointer-events: none; 
        }

        /* åˆ‡æ¢æŒ‰é’® - åŸºç¡€æ ·å¼ï¼Œä¼šè¢«åª’ä½“æŸ¥è¯¢è¦†ç›– */
        .toggle-btn {
            position: absolute;
            right: -20px; /* å®šä½åˆ°ä¾§è¾¹æ å¤–éƒ¨ */
            top: 50%;
            transform: translateY(-50%);
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 50%; /* åœ†å½¢ */
            width: 40px; 
            height: 40px;
            cursor: pointer;
            z-index: 110;
            font-size: 16px;
            display: flex; 
            align-items: center; 
            justify-content: center;
            box-shadow: 0 4px 12px rgba(30, 144, 255, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .toggle-btn:hover {
            background: #0a7be0;
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 6px 16px rgba(30, 144, 255, 0.4);
        }

        /* ç§»åŠ¨ç«¯æ ·å¼å°†åœ¨åª’ä½“æŸ¥è¯¢ä¸­è¦†ç›– */

        /* --- ç½‘æ ¼åŒºåŸŸ --- */
        .grid-area { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            max-width: 600px;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(7, 60px);
            gap: var(--grid-gap);
            background: var(--card-bg);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.1);
            position: relative;
            z-index: 1;
        }

        .cell {
            width: 60px; 
            height: 60px;
            background: #f8f9fa;
            border: 1px solid #eee;
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center;
            cursor: pointer; 
            border-radius: 8px;
            position: relative;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        /* éšå½¢æ°´å° */
        .grid::after {
            content: "Designed by @Darkå™«æœ¯å®¶";
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) rotate(-30deg);
            font-size: 24px;
            color: rgba(0, 0, 0, 0.04);
            white-space: nowrap;
            pointer-events: none;
            z-index: 10;
        }

        .cell {
            width: 55px; height: 55px;
            background: #f8f9fa;
            border: 1px solid #eee;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            cursor: pointer; border-radius: 8px;
            position: relative;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        .cell:hover:not(.opened) { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0,0,0,0.1); border-color: var(--accent); }
        .cell .coord { font-size: 8px; color: #ccc; position: absolute; top: 2px; left: 4px; }
        .cell .score { font-size: 11px; font-weight: bold; margin-top: 4px; }

        .cell.opened { background: #fff !important; border-color: #f0f0f0; cursor: default; }
        .cell.opened::after { content: 'âœ…'; font-size: 16px; }
        .cell.opened .score, .cell.opened .coord { display: none; }

        .cell.best { background: var(--danger) !important; color: white; z-index: 5; box-shadow: 0 0 15px rgba(255,71,87,0.4); border: none; }
        .cell.good { background: #ffa502 !important; color: white; z-index: 4; border: none; }
        .cell.combined-best { 
            border: 3px solid #00ff00 !important; 
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.7) !important;
            animation: pulse-green 2s infinite;
            z-index: 6;
        }
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 255, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0); }
        }

        /* å…¶ä»–ç»„ä»¶ */
        .prob-input-group { margin-bottom: 8px; display: flex; align-items: center; justify-content: space-between; font-size: 13px; }
        .prob-input-group input { width: 50px; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center; }
        .status-bar { margin-top: 15px; padding: 10px; border-radius: 10px; background: #fff; font-size: 13px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); width: 100%; text-align: center; }
        .btn-reset { 
            margin-top: 15px; 
            width: 100%; 
            padding: 14px; 
            background: #2d3436; 
            color: white; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            font-weight: bold; 
            font-size: 16px;
            -webkit-tap-highlight-color: transparent;
        }
        @media screen and (max-width: 768px) {
            .btn-reset {
                padding: 12px;
                font-size: 14px;
            }
        }

        /* æ¡Œé¢ç«¯æ ·å¼ä¼˜åŒ– */
        @media screen and (min-width: 769px) {
            .layout {
                align-items: flex-start; /* é˜²æ­¢å­å…ƒç´ è¢«æ‹‰ä¼¸ */
            }
            .config-panel {
                height: auto;
                position: sticky;
                top: 20px;
                max-height: 700px; /* é™åˆ¶æœ€å¤§é«˜åº¦ */
                overflow-y: auto; /* å…è®¸æ»šåŠ¨ */
            }
            .config-panel.collapsed {
                width: 20px !important; /* æŠ˜å å®½åº¦ï¼Œæ›´çª„ä»¥é€‚åº”åœ†å½¢æŒ‰é’® */
                height: auto; /* é«˜åº¦ç”±å†…å®¹å†³å®š */
                min-height: auto;
                max-height: 700px; /* ä¸å±•å¼€æ—¶ç›¸åŒçš„æœ€å¤§é«˜åº¦ */
                padding: 20px 5px !important;
                background: #eee;
                overflow: hidden; /* éšè—æº¢å‡ºçš„å†…å®¹ */
            }
            .config-panel.collapsed .config-content { 
                opacity: 0; 
                visibility: hidden; 
                pointer-events: none; 
                height: 0; /* ä¸å é«˜åº¦ */
                overflow: hidden;
            }
            .toggle-btn {
                position: absolute;
                top: 50%;
                right: -20px; /* å®šä½åˆ°ä¾§è¾¹æ å³ä¾§å¤–éƒ¨ */
                transform: translateY(-50%);
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background: var(--accent);
                color: white;
                z-index: 110;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 4px 12px rgba(30, 144, 255, 0.3);
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }
            .toggle-btn:hover {
                background: #0a7be0;
                transform: translateY(-50%) scale(1.1);
                box-shadow: 0 6px 16px rgba(30, 144, 255, 0.4);
            }
        }

        /* æ‰‹æœºç«¯é€‚é… (å…³é”®ä¿®æ”¹) */
        @media screen and (max-width: 768px) {
            body {
                padding: 10px;
            }
            .layout { 
                flex-direction: column; 
                align-items: center;
                gap: 10px;
            }
            .config-panel {
                position: relative; 
                top: 0; 
                width: 100% !important; 
                order: 2;
                margin-top: 10px; 
                padding: 15px; 
                height: auto;
                border-radius: 12px;
                max-width: 100%;
                min-height: auto !important; /* è¦†ç›–æ¡Œé¢ç«¯çš„æœ€å°é«˜åº¦ */
                max-height: none !important; /* è¦†ç›–æ¡Œé¢ç«¯çš„æœ€å¤§é«˜åº¦ */
                overflow-y: visible !important;
            }
            .config-panel.collapsed {
                height: auto; 
                width: 100% !important; 
                padding: 15px;
                min-height: auto !important; /* è¦†ç›–æ¡Œé¢ç«¯çš„æœ€å°é«˜åº¦ */
                max-height: none !important;
                overflow: hidden;
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            .toggle-btn {
                position: relative; /* è¦†ç›–æ¡Œé¢ç«¯çš„ç»å¯¹å®šä½ */
                right: auto; 
                top: auto;
                transform: none;
                width: 50px; /* åœ†å½¢æŒ‰é’® */
                height: 50px;
                border-radius: 50%;
                background: var(--accent);
                color: white;
                font-weight: bold;
                font-size: 18px;
                margin: 0 auto 10px auto; /* å±…ä¸­ */
                box-shadow: 0 4px 12px rgba(30, 144, 255, 0.3);
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .toggle-btn:hover {
                background: #0a7be0;
                transform: scale(1.05);
            }
            .grid-area {
                max-width: 100%;
            }
            .grid {
                grid-template-columns: repeat(7, 12vw);
                gap: 3px;
                padding: 8px;
                border-radius: 12px;
            }
            .cell { 
                width: 12vw; 
                height: 12vw; 
                border-radius: 6px;
            }
            .cell .coord { 
                font-size: 7px; 
                top: 1px; 
                left: 2px; 
            }
            .cell .score { 
                font-size: 9px; 
                margin-top: 2px; 
            }
            .watermark { 
                display: none; 
            }
            .header { 
                margin-bottom: 10px; 
            }
            .header h2 { 
                font-size: 18px; 
                padding: 0 10px;
                text-align: center;
            }
            .status-bar {
                margin-top: 10px;
                padding: 8px;
                font-size: 12px;
                border-radius: 8px;
            }
            .prob-input-group {
                font-size: 12px;
                margin-bottom: 6px;
            }
            .prob-input-group input,
            .prob-input-group select {
                width: 45px;
                padding: 5px 3px;
                font-size: 12px;
                min-height: 28px;
                box-sizing: border-box;
            }
            .prob-input-group select {
                width: 180px;
            }
            h3 {
                font-size: 14px !important;
                margin-top: 15px !important;
            }
            #simResults {
                font-size: 11px;
            }
            #simResultsContent {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            #simResultsContent table {
                font-size: 10px;
                min-width: 300px;
            }
            #simResultsContent div[style*="grid-template-columns"] {
                grid-template-columns: repeat(7, 1fr);
                gap: 1px;
            }
            #simResultsContent div[style*="grid-template-columns"] div {
                font-size: 7px;
                padding: 2px;
            }
        }
        
        /* è¶…å°å±å¹•é€‚é… */
        @media screen and (max-width: 360px) {
            .grid {
                grid-template-columns: repeat(7, 10vw);
                gap: 2px;
                padding: 6px;
            }
            .cell { 
                width: 10vw; 
                height: 10vw; 
                border-radius: 4px;
            }
            .cell .coord { 
                font-size: 6px; 
                top: 1px; 
                left: 1px; 
            }
            .cell .score { 
                font-size: 8px; 
                margin-top: 1px; 
            }
            .header h2 { 
                font-size: 15px; 
            }
            .config-panel {
                padding: 12px;
            }
            .toggle-btn {
                font-size: 12px;
                height: 45px;
            }
            .prob-input-group {
                font-size: 11px;
            }
            .prob-input-group input {
                width: 40px;
                font-size: 11px;
            }
            #simResultsContent table {
                min-width: 280px;
                font-size: 9px;
            }
            #simResultsContent div[style*="grid-template-columns"] div {
                font-size: 6px;
                padding: 1px;
            }
        }

        /* æµ®åŠ¨èœå• */
        #menu { display: none; position: fixed; background: white; border-radius: 12px; box-shadow: 0 15px 50px rgba(0,0,0,0.2); padding: 15px; z-index: 1000; min-width: 180px; }
        .menu-btn { display: block; width: 100%; padding: 10px; margin-bottom: 6px; border: none; background: #f8f9fa; border-radius: 8px; cursor: pointer; text-align: left; font-size: 13px; }
        .menu-btn:hover { background: var(--accent); color: white; }

        .watermark { position: fixed; top: 15px; right: 15px; background: rgba(255,255,255,0.9); padding: 8px 12px; border-radius: 10px; border-left: 4px solid var(--accent); box-shadow: 0 10px 25px rgba(0,0,0,0.1); z-index: 1000; font-size: 12px; }

        /* å‘¼å¸ç¯ç‰¹æ•ˆ */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(46, 213, 115, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(46, 213, 115, 0); }
            100% { box-shadow: 0 0 0 0 rgba(46, 213, 115, 0); }
        }
        .algorithm-pulse {
            animation: pulse 2s infinite;
            border-radius: 8px;
            padding: 2px 8px;
        }

        /* æ­å–œå¼¹çª— */
        #winOverlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(8px); z-index: 2000;
            flex-direction: column; justify-content: center; align-items: center;
        }
        .win-card { background: #fff; padding: 30px; border-radius: 20px; text-align: center; width: 80%; max-width: 320px; animation: popIn 0.5s ease forwards; }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>

<div class="watermark">
    <b>ğŸ“º Bç«™@Darkå™«æœ¯å®¶</b>
</div>

<div class="header">
    <h2>é¸£æ½®âœ¨è¸æ½®æ¢å†å°åŠ©æ‰‹ ğŸ¤–</h2>
</div>

<div class="layout">
    <div class="config-panel" id="configPanel">
        <button class="toggle-btn" onclick="toggleConfig()" id="toggleBtn">â—€</button>
        <div class="config-content">
            <h3 style="margin-top:0; font-size:16px;">âš™ï¸ æ¦‚ç‡æƒé‡</h3>
            <div id="probInputs"></div>
            <div id="probWarning" style="font-size: 12px; margin: 8px 0;"></div>
            
            <h3 style="margin-top:25px; font-size:16px;">ğŸ¯ ä¿åº•ç³»ç»Ÿ</h3>
            <div style="margin-bottom:15px;">
                <div class="prob-input-group">
                    <label>å¯ç”¨ä¿åº•</label>
                    <input type="checkbox" id="enablePity" onchange="updatePityEnable(this.checked)" style="width:auto;">
                </div>
                <div class="prob-input-group">
                    <label>ä¿åº•èµ·å§‹ (X)</label>
                    <input type="number" id="pityStart" onchange="updatePityStart(this.value)" min="1" max="20">
                </div>
                <div class="prob-input-group">
                    <label>ä¿åº•ä¸Šé™ (Y)</label>
                    <input type="number" id="pityMax" onchange="updatePityMax(this.value)" min="2" max="50">
                </div>
                <div style="font-size:11px; color:#888; margin-top:8px; padding:6px; background:#f8f9fa; border-radius:6px;">
                    å½“å‰æœªè§¦å‘è®¡æ•°: <span id="currentMissesDisplay"></span>
                </div>
            </div>
            
            <h3 style="margin-top:20px; font-size:16px;">ğŸ¤– ç®—æ³•é€‰æ‹©</h3>
            <div style="margin-bottom:10px;">
                <div class="prob-input-group">
                    <label>æ™ºèƒ½è‡ªåŠ¨åˆ‡æ¢</label>
                    <input type="checkbox" id="autoAlgorithm" onchange="toggleAutoAlgorithm(this.checked)" style="width:auto;">
                </div>
                <div class="prob-input-group">
                    <label>å½“å‰ç®—æ³•</label>
                    <select id="algorithmSelect" onchange="updateAlgorithm(this.value)" style="width:180px; padding:4px;">
                        <option value="greedy">è´ªå¿ƒç®—æ³•ï¼ˆåˆ©ç›Šè‡³ä¸Šï¼‰</option>
                        <option value="heuristic">å¸¦æƒå¯å‘ï¼ˆæˆ˜ç•¥å¸ƒå±€ï¼‰</option>
                        <option value="entropy">ç†µå‡ç®—æ³•ï¼ˆé£é™©å¯¹å†²ï¼‰</option>
                        <option value="comprehensive">ç»¼åˆæ¨èï¼ˆä¸‰é‡å…±è¯†ï¼‰</option>
                        <option value="auto">åŠ¨æ€åˆ‡æ¢ï¼ˆæ—¶æœºæŠŠæ§ï¼‰</option>
                    </select>
                </div>
                <div class="prob-input-group" id="weightParamGroup" style="display:none;">
                    <label>æ¢ç´¢æƒé‡ (w)</label>
                    <input type="number" id="heuristicWeight" value="1.0" step="0.1" min="0.1" max="5.0" onchange="updateHeuristicWeight(this.value)" style="width:60px;">
                </div>
                <div id="weightHelp" style="display:none; font-size:11px; color:#666; margin-top:5px; padding:8px; background:#f8f9fa; border-radius:6px;">
                    <b>æ¢ç´¢æƒé‡è¯´æ˜ï¼š</b> wå€¼è¶Šå¤§ï¼Œç®—æ³•è¶Šå€¾å‘äºé€‰æ‹©å‘¨å›´æœªå¼€æ ¼å­å¤šçš„ä½ç½®ï¼ˆæ¢ç´¢ï¼‰ï¼Œwå€¼è¶Šå°åˆ™è¶Šå…³æ³¨å½“å‰æ ¼å­ç›´æ¥æ”¶ç›Šï¼ˆåˆ©ç”¨ï¼‰ã€‚æ¨èå€¼ï¼š1.0-2.0ã€‚
                </div>
            </div>

            <h3 style="margin-top:20px; font-size:16px;">ğŸ’ª æ‰¹é‡æ¨¡æ‹Ÿ</h3>
            <div style="margin-bottom:10px;">
                <div class="prob-input-group">
                    <label>æ¨¡æ‹Ÿæ¬¡æ•°</label>
                    <input type="number" id="simIterations" value="1000" min="10" max="10000" style="width:70px;">
                </div>
                <button class="btn-reset" onclick="runBatchSimulation()" style="margin-top:10px; background:var(--accent); padding: 12px; font-size: 14px;">å¼€å§‹æ‰¹é‡æ¨¡æ‹Ÿ</button>
                <div id="simResults" style="margin-top:15px; font-size:12px; display:none;">
                    <h4 style="margin:0 0 8px 0; font-size:13px;">æ¨¡æ‹Ÿç»“æœ</h4>
                    <div id="simResultsContent" style="overflow-x: auto;"></div>
                </div>
            </div>
            
            <button class="btn-reset" onclick="confirmReset()">ğŸ”„ é‡ç½®è¿›åº¦</button>
        </div>
    </div>

    <div class="grid-area">
        <div class="grid" id="grid"></div>
        <div class="status-bar" id="statusBar">â³ ç­‰å¾…æ“ä½œ...</div>
    </div>
</div>

<div id="menu">
    <h4 style="margin:0 0 10px 0; font-size:14px;">âœ¨ è§¦å‘äº‹ä»¶</h4>
    <div id="menuButtons"></div>
    <button class="menu-btn" onclick="closeMenu()" style="background:#eee; text-align:center; margin-top:5px;">å–æ¶ˆ</button>
</div>

<div id="winOverlay">
    <div class="win-card">
        <h2>ğŸ‰ æ¢å†è¾¾æˆï¼</h2>
        <p id="winMessage" style="color:#666; font-size:14px; line-height:1.6;"></p>
        <button onclick="confirmReset()" style="padding: 10px 20px; background: var(--primary); color:white; border:none; border-radius:8px; cursor:pointer; width:100%; font-weight:bold;">å¼€å¯æ–°ä¸€è½® ğŸš€</button>
    </div>
</div>

<script>
const size = 7;
const STORAGE_KEY = 'MC_EVENT_HELPER_V1.2_MOBILE';
const defaultData = {
    grid: Array(size * size).fill(false),
    probs: [33, 14, 14, 7, 18, 13, 1],
    clicks: 0,
    enablePity: true,
    pityStart: 3,
    pityMax: 5,
    currentMisses: 0,
    currentAlgorithm: 'greedy',
    heuristicWeight: 1.0,
    autoAlgorithm: false
};

let state = loadState();
let activePos = { r: -1, c: -1 };

// --- é€‚é…ä¸æŠ˜å é€»è¾‘ ---
function toggleConfig() {
    const panel = document.getElementById('configPanel');
    const btn = document.getElementById('toggleBtn');
    const isMobile = window.innerWidth <= 768;

    panel.classList.toggle('collapsed');

    if (panel.classList.contains('collapsed')) {
        // æŠ˜å çŠ¶æ€
        if (isMobile) {
            btn.innerHTML = 'ğŸ”½'; // ç§»åŠ¨ç«¯ä½¿ç”¨å‘ä¸‹ç®­å¤´
        } else {
            btn.innerHTML = 'â–¶'; // æ¡Œé¢ç«¯ä½¿ç”¨å‘å³ç®­å¤´
        }
    } else {
        // å±•å¼€çŠ¶æ€
        if (isMobile) {
            btn.innerHTML = 'ğŸ”¼'; // ç§»åŠ¨ç«¯ä½¿ç”¨å‘ä¸Šç®­å¤´
        } else {
            btn.innerHTML = 'â—€'; // æ¡Œé¢ç«¯ä½¿ç”¨å‘å·¦ç®­å¤´
        }
    }
}

function loadState() {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (!saved) {
        return JSON.parse(JSON.stringify(defaultData));
    }
    
    try {
        const loaded = JSON.parse(saved);
        // ç¡®ä¿æ‰€æœ‰å­—æ®µéƒ½å­˜åœ¨ï¼Œä½¿ç”¨é»˜è®¤å€¼å¡«å……ç¼ºå¤±å­—æ®µ
        const result = {
            ...JSON.parse(JSON.stringify(defaultData)),
            ...loaded
        };
        
        // ç¡®ä¿æ•°ç»„æ˜¯æ–°çš„å¼•ç”¨
        result.grid = Array.isArray(loaded.grid) ? [...loaded.grid] : [...defaultData.grid];
        result.probs = Array.isArray(loaded.probs) ? [...loaded.probs] : [...defaultData.probs];
        
        // ç¡®ä¿æ•°å€¼å­—æ®µæ­£ç¡®
        result.clicks = Number.isInteger(loaded.clicks) ? loaded.clicks : defaultData.clicks;
        result.enablePity = typeof loaded.enablePity === 'boolean' ? loaded.enablePity : defaultData.enablePity;
        result.pityStart = Number.isInteger(loaded.pityStart) ? loaded.pityStart : defaultData.pityStart;
        result.pityMax = Number.isInteger(loaded.pityMax) ? loaded.pityMax : defaultData.pityMax;
        result.currentMisses = Number.isInteger(loaded.currentMisses) ? loaded.currentMisses : defaultData.currentMisses;
        // å¤„ç†ç®—æ³•æ ‡è¯†ç¬¦çš„è½¬æ¢ï¼šå°†'weighted'è½¬æ¢ä¸º'heuristic'
        let loadedAlgorithm = typeof loaded.currentAlgorithm === 'string' ? loaded.currentAlgorithm : defaultData.currentAlgorithm;
        if (loadedAlgorithm === 'weighted') {
            loadedAlgorithm = 'heuristic';
        }
        result.currentAlgorithm = loadedAlgorithm;
        result.heuristicWeight = typeof loaded.heuristicWeight === 'number' ? loaded.heuristicWeight : defaultData.heuristicWeight;
        result.autoAlgorithm = typeof loaded.autoAlgorithm === 'boolean' ? loaded.autoAlgorithm : defaultData.autoAlgorithm;
        
        // ç¡®ä¿gridé•¿åº¦æ­£ç¡®
        if (result.grid.length !== 49) {
            result.grid = Array(49).fill(false);
        }
        
        return result;
    } catch (e) {
        console.error('åŠ è½½çŠ¶æ€å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼:', e);
        return JSON.parse(JSON.stringify(defaultData));
    }
}

function saveState() { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

function init() {
    // ç¡®ä¿çŠ¶æ€æ­£ç¡®åŠ è½½
    state = loadState();
    
    // æ¸²æŸ“è¾“å…¥æ¡†
    const probContainer = document.getElementById('probInputs');
    probContainer.innerHTML = '';
    const labels = ["ä»…å½“å‰ ğŸ“", "åŒåˆ— â†•ï¸", "åŒè¡Œ â†”ï¸", "åŒè¡ŒåŒåˆ— â•", "åå­— ğŸ’ ", "ä¹å®«æ ¼ ğŸ·", "å…¨å¼€ ğŸŒŸ"];

    labels.forEach((label, i) => {
        const div = document.createElement('div');
        div.className = 'prob-input-group';
        div.innerHTML = `<label>${label}</label><input type="number" id="p${i}" value="${state.probs[i]}" onchange="updateProbs(${i}, this.value)" min="0" max="100">`;
        probContainer.appendChild(div);
    });

    // æ¸²æŸ“ä¿åº•é…ç½®
    document.getElementById('enablePity').checked = state.enablePity;
    document.getElementById('pityStart').value = state.pityStart;
    document.getElementById('pityMax').value = state.pityMax;
    document.getElementById('currentMissesDisplay').textContent = state.currentMisses;
    
    // æ¸²æŸ“ç®—æ³•é€‰æ‹©
    document.getElementById('algorithmSelect').value = state.currentAlgorithm;
    document.getElementById('heuristicWeight').value = state.heuristicWeight;
    document.getElementById('autoAlgorithm').checked = state.autoAlgorithm;
    
    // æ ¹æ®ç®—æ³•æ˜¾ç¤º/éšè—æƒé‡å‚æ•°
    const weightGroup = document.getElementById('weightParamGroup');
    const weightHelp = document.getElementById('weightHelp');
    if (state.currentAlgorithm === 'weighted') {
        weightGroup.style.display = 'flex';
        weightHelp.style.display = 'block';
    } else {
        weightGroup.style.display = 'none';
        weightHelp.style.display = 'none';
    }

    // æ¸²æŸ“ç½‘æ ¼
    const gridEl = document.getElementById('grid');
    gridEl.innerHTML = '';
    for (let i = 0; i < 49; i++) {
        const r = Math.floor(i / 7), c = i % 7;
        const cell = document.createElement('div');
        cell.className = 'cell' + (state.grid[i] ? ' opened' : '');
        cell.id = `cell-${i}`;
        cell.innerHTML = `<span class="coord">${r+1},${c+1}</span><span class="score" id="s-${i}">0</span>`;
        cell.onclick = (e) => showMenu(r, c, e);
        gridEl.appendChild(cell);
    }

    // æ¸²æŸ“èœå•æŒ‰é’®
    const menuBtns = document.getElementById('menuButtons');
    menuBtns.innerHTML = '';
    labels.forEach((label, i) => {
        const btn = document.createElement('button');
        btn.className = 'menu-btn';
        btn.innerText = label;
        btn.onclick = () => applyEvent(i + 1);
        menuBtns.appendChild(btn);
    });
    
    // åˆå§‹åŒ–æŠ˜å æŒ‰é’®çŠ¶æ€
    const isMobile = window.innerWidth <= 768;
    const btn = document.getElementById('toggleBtn');
    if (isMobile) {
        btn.innerHTML = 'ğŸ”¼';
    } else {
        btn.innerHTML = 'â—€';
    }
    
    updateAnalysis();
}

// --- éŸ³æ•ˆç³»ç»Ÿ ---
function playEffect(type) {
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const now = audioCtx.currentTime;
    const osc = (f, s, d, w='sine') => {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = w; o.frequency.setValueAtTime(f, s);
        g.gain.setValueAtTime(0.08, s); g.gain.exponentialRampToValueAtTime(0.0001, s + d);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(s); o.stop(s + d);
    };
    if(type === 1) osc(880, now, 0.1);
    else if(type === 7) [523, 659, 783, 1046].forEach((f, i) => osc(f, now + i*0.1, 0.5));
    else osc(587, now, 0.15, 'triangle');
}

// --- é€»è¾‘å¤„ç† ---
function updateProbs(i, val) { state.probs[i] = parseInt(val) || 0; updateAnalysis(); }
function updatePityEnable(checked) { state.enablePity = checked; updateAnalysis(); }
function updatePityStart(val) { state.pityStart = parseInt(val) || 3; updateAnalysis(); }
function updatePityMax(val) { state.pityMax = parseInt(val) || 5; updateAnalysis(); }
function updateAlgorithm(val) {
    state.currentAlgorithm = val;
    if (val === 'auto') {
        state.autoAlgorithm = true;
        document.getElementById('autoAlgorithm').checked = true;
    } else {
        state.autoAlgorithm = false;
        document.getElementById('autoAlgorithm').checked = false;
    }
    const weightGroup = document.getElementById('weightParamGroup');
    const weightHelp = document.getElementById('weightHelp');
    if (val === 'heuristic') {
        weightGroup.style.display = 'flex';
        weightHelp.style.display = 'block';
    } else {
        weightGroup.style.display = 'none';
        weightHelp.style.display = 'none';
    }
    updateAnalysis();
}
function toggleAutoAlgorithm(checked) {
    state.autoAlgorithm = checked;
    if (checked) {
        document.getElementById('algorithmSelect').value = 'auto';
        state.currentAlgorithm = 'auto';
    }
    updateAnalysis();
}

function updateHeuristicWeight(val) {
    state.heuristicWeight = parseFloat(val) || 1.0;
    updateAnalysis();
}

function showMenu(r, c, e) {
    if (state.grid[r * 7 + c]) return;
    activePos = { r, c };
    const menu = document.getElementById('menu');
    menu.style.display = 'block';
    
    // è·å–ç‚¹å‡»ä½ç½®
    const clickX = e.clientX || e.pageX;
    const clickY = e.clientY || e.pageY;
    
    // èœå•å°ºå¯¸
    const menuWidth = 200;
    const menuHeight = 300;
    
    // è®¡ç®—ä½ç½®ï¼Œç¡®ä¿åœ¨è§†å£å†…
    let left = clickX;
    let top = clickY;
    
    // æ£€æŸ¥å³è¾¹ç•Œ
    if (left + menuWidth > window.innerWidth) {
        left = window.innerWidth - menuWidth - 10;
    }
    // æ£€æŸ¥ä¸‹è¾¹ç•Œ
    if (top + menuHeight > window.innerHeight) {
        top = window.innerHeight - menuHeight - 10;
    }
    // ç¡®ä¿ä¸å°äº0
    left = Math.max(10, left);
    top = Math.max(10, top);
    
    menu.style.left = left + 'px';
    menu.style.top = top + 'px';
}

function closeMenu() { document.getElementById('menu').style.display = 'none'; }

function applyEvent(type) {
    playEffect(type);
    const { r, c } = activePos;
    const mark = (row, col) => {
        if (row >= 0 && row < 7 && col >= 0 && col < 7) {
            const idx = row * 7 + col;
            state.grid[idx] = true;
            document.getElementById(`cell-${idx}`).classList.add('opened');
        }
    };
    if (type === 1) {
        mark(r, c);
        state.currentMisses++;
    } else {
        // ç±»å‹ 2-7
        if (type === 2) for(let i=0; i<7; i++) mark(i, c);
        else if (type === 3) for(let i=0; i<7; i++) mark(r, i);
        else if (type === 4) { for(let i=0; i<7; i++) { mark(i, c); mark(r, i); } }
        else if (type === 5) { mark(r, c); mark(r-1,c); mark(r+1,c); mark(r,c-1); mark(r,c+1); }
        else if (type === 6) { for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) mark(r+i, c+j); }
        else if (type === 7) { state.grid.fill(true); init(); }
        state.currentMisses = 0;
    }

    state.clicks++;
    closeMenu();
    updateAnalysis();
}

// ç®—æ³•å¯¹è±¡
const Algorithms = {
    // è´ªå¿ƒç®—æ³•ï¼šè®¡ç®—åŸºç¡€æ”¶ç›Šï¼Œåç»­ä¼šç»Ÿä¸€å½’ä¸€åŒ–
    greedy: function(p, grid) {
        let scores = [];
        for (let i = 0; i < 49; i++) {
            const r = Math.floor(i / 7), c = i % 7;
            if (grid[i]) continue;
            let g = 0;
            // åŸºç¡€æ”¶ç›Šè®¡ç®—ï¼ˆä¸å…¶ä»–ç®—æ³•ä¿æŒä¸€è‡´ï¼‰
            let rg=0, cg=0, comb=0, cross=0, box=0;
            for(let j=0; j<7; j++) {
                if(!grid[r*7+j]) { rg++; comb++; }
                if(!grid[j*7+c]) { cg++; if(j!==r) comb++; }
            }
            g = p[0]*1 + p[1]*cg + p[2]*rg + p[3]*comb;
            [[0,0],[1,0],[-1,0],[0,1],[0,-1]].forEach(o => {
                let nr=r+o[0], nc=c+o[1];
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) cross++;
            });
            for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
                let nr=r+dr, nc=c+dc;
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) box++;
            }
            g += p[4]*cross + p[5]*box + p[6]*(grid.filter(v=>!v).length);
            scores.push({ i, score: g });
        }
        return scores;
    },
    
    // å¸¦æƒå¯å‘å¼ï¼šf(n) = g(n) + w * h(n)
    heuristic: function(p, grid, weight) {
        let scores = [];
        // è®¡ç®—æ¯ä¸ªæ ¼å­çš„ g(n)ï¼ˆåŸºç¡€æ”¶ç›Šï¼‰
        for (let i = 0; i < 49; i++) {
            const r = Math.floor(i / 7), c = i % 7;
            if (grid[i]) continue;
            let g = 0;
            // åŸºç¡€æ”¶ç›Šè®¡ç®—ï¼ˆä¸è´ªå¿ƒç›¸åŒï¼‰
            let rg=0, cg=0, comb=0, cross=0, box=0;
            for(let j=0; j<7; j++) {
                if(!grid[r*7+j]) { rg++; comb++; }
                if(!grid[j*7+c]) { cg++; if(j!==r) comb++; }
            }
            g = p[0]*1 + p[1]*cg + p[2]*rg + p[3]*comb;
            [[0,0],[1,0],[-1,0],[0,1],[0,-1]].forEach(o => {
                let nr=r+o[0], nc=c+o[1];
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) cross++;
            });
            for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
                let nr=r+dr, nc=c+dc;
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) box++;
            }
            g += p[4]*cross + p[5]*box + p[6]*(grid.filter(v=>!v).length);
            
            // æ”¹è¿›çš„å¯å‘å¼å‡½æ•° h(n)ï¼šè€ƒè™‘æ›´å…¨é¢çš„æ¢ç´¢ä»·å€¼
            // 1. å‘¨å›´æœªå¼€å¯æ ¼å­æ•°é‡ï¼ˆ3x3åŒºåŸŸï¼‰
            let h_local = 0;
            for(let dr=-1;dr<=1;dr++) {
                for(let dc=-1;dc<=1;dc++) {
                    let nr=r+dr, nc=c+dc;
                    if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) {
                        h_local++;
                    }
                }
            }
            // 2. è¡Œåˆ—æ½œåœ¨æ”¶ç›Šï¼šè¯¥æ ¼å­æ‰€åœ¨è¡Œå’Œåˆ—çš„æœªå¼€å¯æ ¼å­æ•°
            let row_unopened = 0;
            let col_unopened = 0;
            for(let j=0; j<7; j++) {
                if(!grid[r*7+j]) row_unopened++;
                if(!grid[j*7+c]) col_unopened++;
            }
            // 3. ç»¼åˆå¯å‘å¼å€¼ï¼šåŠ æƒç»„åˆ
            // å½’ä¸€åŒ–ï¼šh_localæœ€å¤§9ï¼Œrow_unopenedå’Œcol_unopenedæœ€å¤§7
            const h_local_norm = h_local / 9;
            const row_norm = row_unopened / 7;
            const col_norm = col_unopened / 7;
            
            // ç»¼åˆå¯å‘å¼å€¼ï¼šæ›´æ³¨é‡å±€éƒ¨æ¢ç´¢ï¼Œä½†ä¹Ÿè€ƒè™‘è¡Œåˆ—æ½œåŠ›
            const h = h_local_norm * 0.6 + row_norm * 0.2 + col_norm * 0.2;
            
            // è°ƒæ•´æƒé‡åº”ç”¨ï¼šå½“gå€¼è¾ƒå¤§æ—¶ï¼Œæƒé‡å½±å“åº”ç›¸å¯¹å‡å°
            const g_normalized = g / 100; // ä¼°è®¡gçš„æœ€å¤§å€¼å¤§çº¦åœ¨100å·¦å³
            const adjusted_weight = weight * (1 - Math.min(g_normalized, 0.5));
            
            const f = g + adjusted_weight * h * 50; // ä¹˜ä»¥50ä»¥åŒ¹é…gçš„å°ºåº¦
            scores.push({ i, score: f });
        }
        return scores;
    },
    
    // ç†µå‡ç®—æ³•ï¼šä¼˜å…ˆè®¡ç®—å¹¶æ ‡æ³¨å‘¨å›´é‚»å±…ï¼ˆæœªå¼€å¯ç©ºæ ¼ï¼‰æœ€å°‘çš„å­¤ç«‹æ ¼å­
    entropy: function(p, grid) {
        let scores = [];
        
        // é¦–å…ˆï¼Œè®¡ç®—æ¯ä¸ªæ ¼å­çš„å­¤ç«‹åº¦
        for (let i = 0; i < 49; i++) {
            const r = Math.floor(i / 7), c = i % 7;
            if (grid[i]) continue;
            
            // åŸºç¡€æ”¶ç›Š g(n)
            let g = 0;
            let rg=0, cg=0, comb=0, cross=0, box=0;
            for(let j=0; j<7; j++) {
                if(!grid[r*7+j]) { rg++; comb++; }
                if(!grid[j*7+c]) { cg++; if(j!==r) comb++; }
            }
            g = p[0]*1 + p[1]*cg + p[2]*rg + p[3]*comb;
            [[0,0],[1,0],[-1,0],[0,1],[0,-1]].forEach(o => {
                let nr=r+o[0], nc=c+o[1];
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) cross++;
            });
            for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
                let nr=r+dr, nc=c+dc;
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) box++;
            }
            g += p[4]*cross + p[5]*box + p[6]*(grid.filter(v=>!v).length);
            
            // è®¡ç®—å‘¨å›´æœªå¼€å¯é‚»å±…çš„æ•°é‡ï¼ˆ8è¿é€šï¼ŒåŒ…æ‹¬å¯¹è§’çº¿ï¼‰
            let neighborCount = 0;
            for(let dr=-1;dr<=1;dr++) {
                for(let dc=-1;dc<=1;dc++) {
                    if(dr===0 && dc===0) continue;
                    let nr=r+dr, nc=c+dc;
                    if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) {
                        neighborCount++;
                    }
                }
            }
            
            // è®¡ç®—å­¤ç«‹åº¦ï¼šé‚»å±…è¶Šå°‘ï¼Œå­¤ç«‹åº¦è¶Šé«˜
            // æœ€å¤§é‚»å±…æ•°æ˜¯8
            const isolationScore = (8 - neighborCount) / 8;
            
            // è®¡ç®—åŒºåŸŸå¯†åº¦ï¼šå‘¨å›´3x3åŒºåŸŸå†…æœªå¼€å¯æ ¼å­çš„æ¯”ä¾‹
            let areaUnopened = 0;
            let areaTotal = 0;
            for(let dr=-1;dr<=1;dr++) {
                for(let dc=-1;dc<=1;dc++) {
                    let nr=r+dr, nc=c+dc;
                    if(nr>=0&&nr<7&&nc>=0&&nc<7) {
                        areaTotal++;
                        if(!grid[nr*7+nc]) areaUnopened++;
                    }
                }
            }
            const densityScore = areaUnopened / areaTotal;
            
            // æœ€ç»ˆåˆ†æ•° = åŸºç¡€æ”¶ç›Š + å­¤ç«‹åº¦æƒé‡ + å¯†åº¦æƒé‡
            // è°ƒæ•´æƒé‡ï¼šåœ¨æ¸¸æˆåæœŸï¼Œæ›´æ³¨é‡æ¸…ç†å­¤ç«‹æ ¼å­
            const totalUnopened = grid.filter(v=>!v).length;
            const gamePhase = totalUnopened / 49; // 0-1ï¼Œè¶Šå°è¡¨ç¤ºè¶ŠåæœŸ
            
            // åæœŸæ—¶å¢åŠ å­¤ç«‹åº¦æƒé‡
            const isolationWeight = 80 * (1 - gamePhase);
            const densityWeight = 30 * gamePhase;
            
            const score = g + isolationScore * isolationWeight + densityScore * densityWeight;
            scores.push({ i, score: score });
        }
        return scores;
    },
    
    // ç»¼åˆæ¨èç®—æ³•ï¼šé€‰æ‹©åœ¨ä¸‰ç§ç®—æ³•ä¸­å¾—åˆ†æœ€é«˜çš„æ ¼å­
    comprehensive: function(p, grid, heuristicWeight) {
        let scores = [];
        
        // è®¡ç®—ä¸‰ç§ç®—æ³•çš„åˆ†æ•°
        const greedyScores = this.greedy(p, grid);
        const heuristicScores = this.heuristic(p, grid, heuristicWeight);
        const entropyScores = this.entropy(p, grid);
        
        // å°†åˆ†æ•°è½¬æ¢ä¸ºå­—å…¸ä»¥ä¾¿å¿«é€ŸæŸ¥æ‰¾
        const greedyMap = new Map();
        const heuristicMap = new Map();
        const entropyMap = new Map();
        
        greedyScores.forEach(s => greedyMap.set(s.i, s.score));
        heuristicScores.forEach(s => heuristicMap.set(s.i, s.score));
        entropyScores.forEach(s => entropyMap.set(s.i, s.score));
        
        // è®¡ç®—æ¯ä¸ªæ ¼å­çš„ç»¼åˆåˆ†æ•°
        for (let i = 0; i < 49; i++) {
            if (grid[i]) continue;
            
            const greedyScore = greedyMap.get(i) || 0;
            const heuristicScore = heuristicMap.get(i) || 0;
            const entropyScore = entropyMap.get(i) || 0;
            
            // ç»¼åˆåˆ†æ•°ï¼šä¸‰ç§ç®—æ³•çš„åŠ æƒå¹³å‡
            // å¯ä»¥è°ƒæ•´æƒé‡ï¼Œè¿™é‡Œå…ˆä½¿ç”¨ç®€å•å¹³å‡
            const combinedScore = (greedyScore + heuristicScore + entropyScore) / 3;
            
            scores.push({ i, score: combinedScore });
        }
        
        return scores;
    }
};

// æ¨¡æ‹Ÿå•ä¸ªæ¸¸æˆç›´åˆ°å®Œæˆï¼Œè¿”å›ç‚¹å‡»æ¬¡æ•°
function runSimulation(algorithmType, iterations = 1000) {
    // å¤åˆ¶å½“å‰çŠ¶æ€è®¾ç½®
    const baseProbs = [...state.probs];
    const enablePity = state.enablePity;
    const pityStart = state.pityStart;
    const pityMax = state.pityMax;
    const heuristicWeight = state.heuristicWeight;
    
    // æ¨¡æ‹Ÿå‡½æ•°
    function simulateOneGame() {
        let grid = Array(49).fill(false);
        let clicks = 0;
        let currentMisses = 0;
        
        // è¾…åŠ©å‡½æ•°ï¼šåº”ç”¨äº‹ä»¶
        const applyEventToGrid = (type, r, c, grid) => {
            const mark = (row, col) => {
                if (row >= 0 && row < 7 && col >= 0 && col < 7) {
                    const idx = row * 7 + col;
                    grid[idx] = true;
                }
            };
            if (type === 1) {
                mark(r, c);
                currentMisses++;
            } else {
                if (type === 2) for(let i=0; i<7; i++) mark(i, c);
                else if (type === 3) for(let i=0; i<7; i++) mark(r, i);
                else if (type === 4) { for(let i=0; i<7; i++) { mark(i, c); mark(r, i); } }
                else if (type === 5) { mark(r, c); mark(r-1,c); mark(r+1,c); mark(r,c-1); mark(r,c+1); }
                else if (type === 6) { for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) mark(r+i, c+j); }
                else if (type === 7) { grid.fill(true); }
                currentMisses = 0;
            }
            return grid;
        };
        
        // é€‰æ‹©äº‹ä»¶ç±»å‹ï¼ˆè€ƒè™‘ä¿åº•ï¼‰
        const chooseEventType = () => {
            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å¤§ä¿åº•æ¬¡æ•°ï¼Œå¦‚æœæ˜¯åˆ™å¿…è§¦å‘éç±»å‹1äº‹ä»¶
            if (enablePity && currentMisses >= pityMax) {
                // å¿…è§¦å‘éç±»å‹1äº‹ä»¶ï¼ˆ2-7ï¼‰
                // éšæœºé€‰æ‹©2-7ä¸­çš„ä¸€ç§ï¼ŒæŒ‰åŸå§‹æ¦‚ç‡æ¯”ä¾‹
                const nonType1Probs = baseProbs.slice(1); // è·å–ç±»å‹2-7çš„æ¦‚ç‡
                const totalNonType1 = nonType1Probs.reduce((a, b) => a + b, 0);
                const normalizedNonType1 = nonType1Probs.map(p => p / totalNonType1);
                
                const rand = Math.random();
                let accum = 0;
                for (let i = 0; i < 6; i++) {
                    accum += normalizedNonType1[i];
                    if (rand <= accum) return i + 2; // è¿”å›2-7
                }
                return 7; // é»˜è®¤
            }
            
            // åŠ¨æ€æ¦‚ç‡è°ƒæ•´
            let adjustedProbs = [...baseProbs];
            if (enablePity && currentMisses >= pityStart) {
                const progress = Math.min((currentMisses - pityStart + 1) / (pityMax - pityStart + 1), 1.0);
                // é€æ­¥å¢åŠ éç±»å‹1äº‹ä»¶çš„æ¦‚ç‡
                // ç±»å‹1çš„æ¦‚ç‡å‡å°‘ï¼Œå…¶ä»–ç±»å‹çš„æ¦‚ç‡æŒ‰æ¯”ä¾‹å¢åŠ 
                const type1Reduction = 0.5 * progress; // æœ€å¤šå‡å°‘50%
                adjustedProbs[0] = baseProbs[0] * (1 - type1Reduction);
                
                // å°†å‡å°‘çš„æ¦‚ç‡åˆ†é…åˆ°å…¶ä»–ç±»å‹
                const reductionAmount = baseProbs[0] * type1Reduction;
                const otherTotal = baseProbs.slice(1).reduce((a, b) => a + b, 0);
                
                for (let i = 1; i < 7; i++) {
                    adjustedProbs[i] = baseProbs[i] + (reductionAmount * (baseProbs[i] / otherTotal));
                }
            }
            
            // å½’ä¸€åŒ–
            const sum = adjustedProbs.reduce((a, b) => a + b, 0);
            const normalized = adjustedProbs.map(p => p / sum);
            
            // éšæœºé€‰æ‹©
            const rand = Math.random();
            let accum = 0;
            for (let i = 0; i < 7; i++) {
                accum += normalized[i];
                if (rand <= accum) return i + 1;
            }
            return 7;
        };
        
        // é€‰æ‹©æœ€ä½³æ ¼å­
        const chooseBestCell = (grid, algorithmType) => {
            // åŠ¨æ€æ¦‚ç‡è°ƒæ•´ï¼ˆç”¨äºè®¡ç®—åˆ†æ•°ï¼Œä¸chooseEventTypeä¸€è‡´ï¼‰
            let adjustedProbs = [...baseProbs];
            if (enablePity && currentMisses >= pityStart) {
                const progress = Math.min((currentMisses - pityStart + 1) / (pityMax - pityStart + 1), 1.0);
                
                // å¦‚æœè¾¾åˆ°æœ€å¤§ä¿åº•æ¬¡æ•°ï¼Œç±»å‹1çš„æ¦‚ç‡ä¸º0
                if (currentMisses >= pityMax) {
                    adjustedProbs[0] = 0;
                    // å…¶ä»–ç±»å‹çš„æ¦‚ç‡æŒ‰åŸå§‹æ¯”ä¾‹åˆ†é…
                    const otherTotal = baseProbs.slice(1).reduce((a, b) => a + b, 0);
                    for (let i = 1; i < 7; i++) {
                        adjustedProbs[i] = (baseProbs[i] / otherTotal) * 100;
                    }
                } else {
                    // é€æ­¥è°ƒæ•´æ¦‚ç‡
                    const type1Reduction = 0.5 * progress;
                    adjustedProbs[0] = baseProbs[0] * (1 - type1Reduction);
                    
                    // å°†å‡å°‘çš„æ¦‚ç‡åˆ†é…åˆ°å…¶ä»–ç±»å‹
                    const reductionAmount = baseProbs[0] * type1Reduction;
                    const otherTotal = baseProbs.slice(1).reduce((a, b) => a + b, 0);
                    
                    for (let i = 1; i < 7; i++) {
                        adjustedProbs[i] = baseProbs[i] + (reductionAmount * (baseProbs[i] / otherTotal));
                    }
                }
                
                // ç¡®ä¿æ€»å’Œä¸º100
                const total = adjustedProbs.reduce((a, b) => a + b, 0);
                if (total > 0) {
                    for (let i = 0; i < 7; i++) {
                        adjustedProbs[i] = (adjustedProbs[i] * 100) / total;
                    }
                }
            }
            const p = adjustedProbs.map(v => v / 100);
            
            // å¦‚æœç®—æ³•ç±»å‹æ˜¯'auto'ï¼Œæ ¹æ®å½“å‰æœªå¼€å¯æ ¼å­æ•°åŠ¨æ€é€‰æ‹©ç®—æ³•
            let actualAlgorithm = algorithmType;
            if (algorithmType === 'auto') {
                // è®¡ç®—æœªå¼€å¯æ ¼å­æ•°
                let unopened = 0;
                for (let i = 0; i < 49; i++) {
                    if (!grid[i]) unopened++;
                }
                // ä½¿ç”¨å¸¦æ»åçš„é˜¶æ®µåˆ¤æ–­
                let stageForSim;
                if (unopened > 37) {
                    stageForSim = "å‰æœŸ";
                } else if (unopened > 35 && window.lastStage === "å‰æœŸ") {
                    stageForSim = "å‰æœŸ";
                } else if (unopened >= 17) {
                    stageForSim = "ä¸­æœŸ";
                } else if (unopened >= 15 && window.lastStage === "ä¸­æœŸ") {
                    stageForSim = "ä¸­æœŸ";
                } else if (unopened >= 13) {
                    stageForSim = "åæœŸ";
                } else {
                    stageForSim = "æœ«æœŸ";
                }
                
                if (stageForSim === "å‰æœŸ") {
                    actualAlgorithm = 'heuristic';
                } else if (stageForSim === "ä¸­æœŸ") {
                    actualAlgorithm = 'greedy';
                } else {
                    actualAlgorithm = 'entropy';
                }
            }
            
            let scores;
            if (actualAlgorithm === 'greedy') {
                scores = Algorithms.greedy(p, grid);
            } else if (actualAlgorithm === 'heuristic') {
                scores = Algorithms.heuristic(p, grid, heuristicWeight);
            } else if (actualAlgorithm === 'entropy') {
                scores = Algorithms.entropy(p, grid);
            } else if (actualAlgorithm === 'comprehensive') {
                scores = Algorithms.comprehensive(p, grid, heuristicWeight);
            } else {
                scores = Algorithms.greedy(p, grid);
            }
            
            // æ‰¾åˆ°æœ€é«˜åˆ†
            if (scores.length === 0) return null;
            let maxScore = -Infinity;
            // æ”¶é›†æ‰€æœ‰æœ€é«˜åˆ†çš„æ ¼å­ç´¢å¼•
            let bestIndices = [];
            for (const s of scores) {
                if (s.score > maxScore) {
                    maxScore = s.score;
                    bestIndices = [s.i];
                } else if (s.score === maxScore) {
                    bestIndices.push(s.i);
                }
            }
            if (bestIndices.length === 0) return null;
            // éšæœºé€‰æ‹©ä¸€ä¸ªæœ€é«˜åˆ†æ ¼å­
            const randomIndex = Math.floor(Math.random() * bestIndices.length);
            const bestIdx = bestIndices[randomIndex];
            return { r: Math.floor(bestIdx / 7), c: bestIdx % 7 };
        };
        
        // ä¸»å¾ªç¯
        while (grid.some(cell => !cell)) {
            const best = chooseBestCell(grid, algorithmType);
            if (!best) break;
            const eventType = chooseEventType();
            applyEventToGrid(eventType, best.r, best.c, grid);
            clicks++;
        }
        return clicks;
    }
    
    // è¿è¡Œå¤šæ¬¡æ¨¡æ‹Ÿ
    const results = [];
    for (let i = 0; i < iterations; i++) {
        results.push(simulateOneGame());
    }
    return results;
}

function updateAnalysis() {
    let unopened = 0;
    let scores = [];
    
    // ç»Ÿè®¡æœªå¼€å¯æ ¼å­æ•°é‡
    for (let i = 0; i < 49; i++) {
        if (!state.grid[i]) unopened++;
    }
    
    // åˆ¤æ–­é˜¶æ®µå¹¶ç¡®å®šæ¨èç®—æ³•ï¼ˆåŸºäºå®é™…è¡¨ç°ä¼˜åŒ–ï¼‰
    let stage, recommendedAlgorithm;
    
    // ä¸Šæ¬¡é˜¶æ®µè®°å½•
    if (!window.lastStage) window.lastStage = '';
    
    // æ ¹æ®æœªå¼€å¯æ ¼å­æ•°åˆ¤æ–­é˜¶æ®µï¼ˆä¼˜åŒ–åçš„é˜ˆå€¼ï¼‰
    // å‰æœŸï¼šå¤§é‡æœªå¼€å¯æ ¼å­ï¼Œéœ€è¦æ¢ç´¢
    if (unopened > 30) { // é™ä½é˜ˆå€¼ï¼Œè®©å¯å‘å¼ç®—æ³•æ›´æ—©ä»‹å…¥
        stage = "å‰æœŸ";
        recommendedAlgorithm = "heuristic";
    } 
    // ä¸­æœŸï¼šä¸­ç­‰æ•°é‡æ ¼å­ï¼Œå¹³è¡¡æ¢ç´¢ä¸åˆ©ç”¨
    else if (unopened >= 10) {
        stage = "ä¸­æœŸ";
        // åœ¨ä¸­æœŸï¼Œæ ¹æ®æ ¼å­åˆ†å¸ƒå†³å®šä½¿ç”¨è´ªå¿ƒè¿˜æ˜¯å¯å‘å¼
        // è®¡ç®—å­¤ç«‹æ ¼å­æ•°é‡
        let isolatedCount = 0;
        for (let i = 0; i < 49; i++) {
            if (state.grid[i]) continue;
            const r = Math.floor(i / 7), c = i % 7;
            let neighborCount = 0;
            for(let dr=-1;dr<=1;dr++) {
                for(let dc=-1;dc<=1;dc++) {
                    if(dr===0 && dc===0) continue;
                    let nr=r+dr, nc=c+dc;
                    if(nr>=0&&nr<7&&nc>=0&&nc<7 && !state.grid[nr*7+nc]) {
                        neighborCount++;
                    }
                }
            }
            if (neighborCount <= 2) isolatedCount++;
        }
        // å¦‚æœå­¤ç«‹æ ¼å­è¾ƒå¤šï¼Œä½¿ç”¨ç†µå‡ç®—æ³•
        if (isolatedCount > unopened * 0.3) {
            recommendedAlgorithm = "entropy";
        } else {
            recommendedAlgorithm = "greedy";
        }
    } 
    // åæœŸï¼šå°‘é‡æ ¼å­ï¼Œä¼˜å…ˆæ¸…ç†å­¤ç«‹æ ¼å­
    else {
        stage = "åæœŸ";
        recommendedAlgorithm = "entropy";
    }
    
    // è®°å½•æœ¬æ¬¡é˜¶æ®µ
    window.lastStage = stage;
    
    // åŠ¨æ€è°ƒæ•´å¯å‘å¼æƒé‡ï¼šå‰æœŸæƒé‡è¾ƒé«˜ï¼ŒåæœŸé™ä½
    if (stage === "å‰æœŸ") {
        // å‰æœŸï¼šæ¢ç´¢æ›´é‡è¦ï¼Œæƒé‡è¾ƒé«˜ï¼ˆ1.5-2.0ï¼‰
        state.heuristicWeight = Math.max(1.5, Math.min(2.0, 
            state.heuristicWeight || 1.5
        ));
    } else if (stage === "ä¸­æœŸ") {
        // ä¸­æœŸï¼šå¹³è¡¡æ¢ç´¢ä¸åˆ©ç”¨ï¼ˆ1.0-1.5ï¼‰
        state.heuristicWeight = Math.max(1.0, Math.min(1.5,
            state.heuristicWeight || 1.0
        ));
    } else {
        // åæœŸï¼šæ›´æ³¨é‡åˆ©ç”¨ï¼ˆ0.5-1.0ï¼‰
        state.heuristicWeight = Math.max(0.5, Math.min(1.0,
            state.heuristicWeight || 0.8
        ));
    }
    
    // æ›´æ–°æƒé‡è¾“å…¥æ¡†æ˜¾ç¤º
    const weightInput = document.getElementById('heuristicWeight');
    if (weightInput) {
        weightInput.value = state.heuristicWeight.toFixed(1);
    }
    
    // å¤„ç†ç®—æ³•é€‰æ‹©é€»è¾‘
    let currentAlgorithm = state.currentAlgorithm;
    const algorithmSelect = document.getElementById('algorithmSelect');
    
    // å¦‚æœå¯ç”¨äº†æ™ºèƒ½è‡ªåŠ¨åˆ‡æ¢ï¼Œåˆ™ä½¿ç”¨æ¨èç®—æ³•
    if (state.autoAlgorithm) {
        currentAlgorithm = recommendedAlgorithm;
        // ç¡®ä¿ä¸‹æ‹‰èœå•æ˜¾ç¤ºä¸º'auto'
        if (algorithmSelect.value !== 'auto') {
            algorithmSelect.value = 'auto';
        }
    } else {
        // å¦‚æœå½“å‰ç®—æ³•æ˜¯'auto'ä½†æœªå¯ç”¨è‡ªåŠ¨åˆ‡æ¢ï¼Œåˆ™åˆ‡æ¢åˆ°æ¨èç®—æ³•
        if (currentAlgorithm === 'auto') {
            currentAlgorithm = recommendedAlgorithm;
            algorithmSelect.value = recommendedAlgorithm;
        }
    }
    
    // åŠ¨æ€æ¦‚ç‡è°ƒæ•´ï¼ˆä¸æ¨¡æ‹Ÿä¸­çš„é€»è¾‘ä¸€è‡´ï¼‰
    let adjustedProbs = [...state.probs];
    if (state.enablePity && state.currentMisses >= state.pityStart) {
        const progress = Math.min((state.currentMisses - state.pityStart + 1) / (state.pityMax - state.pityStart + 1), 1.0);
        
        // å¦‚æœè¾¾åˆ°æœ€å¤§ä¿åº•æ¬¡æ•°ï¼Œç±»å‹1çš„æ¦‚ç‡ä¸º0ï¼Œå…¶ä»–ç±»å‹æ¦‚ç‡æŒ‰æ¯”ä¾‹å¢åŠ 
        if (state.currentMisses >= state.pityMax) {
            adjustedProbs[0] = 0;
            // å…¶ä»–ç±»å‹çš„æ¦‚ç‡æŒ‰åŸå§‹æ¯”ä¾‹åˆ†é…
            const otherTotal = state.probs.slice(1).reduce((a, b) => a + b, 0);
            for (let i = 1; i < 7; i++) {
                adjustedProbs[i] = (state.probs[i] / otherTotal) * 100;
            }
        } else {
            // é€æ­¥è°ƒæ•´æ¦‚ç‡
            const type1Reduction = 0.5 * progress; // æœ€å¤šå‡å°‘50%
            adjustedProbs[0] = state.probs[0] * (1 - type1Reduction);
            
            // å°†å‡å°‘çš„æ¦‚ç‡åˆ†é…åˆ°å…¶ä»–ç±»å‹
            const reductionAmount = state.probs[0] * type1Reduction;
            const otherTotal = state.probs.slice(1).reduce((a, b) => a + b, 0);
            
            for (let i = 1; i < 7; i++) {
                adjustedProbs[i] = state.probs[i] + (reductionAmount * (state.probs[i] / otherTotal));
            }
        }
        
        // ç¡®ä¿æ€»å’Œä¸º100
        const total = adjustedProbs.reduce((a, b) => a + b, 0);
        if (total > 0) {
            for (let i = 0; i < 7; i++) {
                adjustedProbs[i] = (adjustedProbs[i] * 100) / total;
            }
        }
    }
    
    const p = adjustedProbs.map(v => v / 100);
    const totalP = state.probs.reduce((a, b) => a + b, 0);
    const warningEl = document.getElementById('probWarning');
    warningEl.innerText = `å½“å‰æ€»æƒé‡: ${totalP}% | æœªè§¦å‘è®¡æ•°: ${state.currentMisses}`;
    warningEl.style.color = totalP === 100 ? 'var(--primary)' : 'var(--danger)';
    
    // æ›´æ–°æ˜¾ç¤º
    document.getElementById('currentMissesDisplay').textContent = state.currentMisses;

    // è®¡ç®—æ‰€æœ‰ç®—æ³•çš„åˆ†æ•°ï¼Œå¹¶ç»Ÿä¸€åˆ°ç›¸åŒçš„æ€»åˆ†å°ºåº¦
    const allScores = {
        greedy: Algorithms.greedy(p, state.grid),
        heuristic: Algorithms.heuristic(p, state.grid, state.heuristicWeight),
        entropy: Algorithms.entropy(p, state.grid),
        comprehensive: Algorithms.comprehensive(p, state.grid, state.heuristicWeight)
    };
    
    // è®¡ç®—æ¯ä¸ªç®—æ³•çš„æ€»åˆ†
    const algorithmTotals = {};
    Object.keys(allScores).forEach(alg => {
        algorithmTotals[alg] = allScores[alg].reduce((sum, s) => sum + s.score, 0);
    });
    
    // æ‰¾åˆ°ç›®æ ‡æ€»åˆ†ï¼šä½¿ç”¨è´ªå¿ƒç®—æ³•çš„æ€»åˆ†ä½œä¸ºåŸºå‡†ï¼ˆå› ä¸ºå®ƒæœ€ç¨³å®šï¼‰
    const targetTotal = algorithmTotals.greedy;
    
    // è°ƒæ•´æ¯ä¸ªç®—æ³•çš„åˆ†æ•°ï¼Œä½¿å®ƒä»¬çš„æ€»åˆ†ä¸ç›®æ ‡æ€»åˆ†ä¸€è‡´
    const normalizedScores = {};
    Object.keys(allScores).forEach(alg => {
        const currentTotal = algorithmTotals[alg];
        const scaleFactor = currentTotal > 0 ? targetTotal / currentTotal : 1;
        
        normalizedScores[alg] = allScores[alg].map(s => ({
            i: s.i,
            score: s.score * scaleFactor
        }));
    });
    
    // ç°åœ¨æ‰€æœ‰ç®—æ³•çš„æ€»åˆ†åº”è¯¥å¤§è‡´ç›¸åŒï¼Œä½†ä¸ºäº†æ›´å¥½çš„æ˜¾ç¤ºï¼Œå¯ä»¥å†è¿›è¡Œä¸€æ¬¡å½’ä¸€åŒ–åˆ°0-100
    // æ”¶é›†æ‰€æœ‰è°ƒæ•´åçš„åˆ†æ•°
    let allNormalizedValues = [];
    Object.values(normalizedScores).forEach(algScores => {
        algScores.forEach(s => allNormalizedValues.push(s.score));
    });
    const minScore = Math.min(...allNormalizedValues);
    const maxScore = Math.max(...allNormalizedValues);
    const range = maxScore - minScore;
    
    // æœ€ç»ˆå½’ä¸€åŒ–åˆ°0-100
    Object.keys(normalizedScores).forEach(alg => {
        normalizedScores[alg] = normalizedScores[alg].map(s => {
            if (range === 0) return { i: s.i, score: 50 };
            const normalizedScore = ((s.score - minScore) / range) * 100;
            return { i: s.i, score: normalizedScore };
        });
    });
    
    // è®¡ç®—ç»¼åˆåˆ†æ•°ï¼šä¸‰ä¸ªç®—æ³•åˆ†æ•°çš„å¹³å‡å€¼
    const combinedScores = [];
    for (let i = 0; i < 49; i++) {
        if (state.grid[i]) continue;
        let sum = 0;
        let count = 0;
        Object.keys(normalizedScores).forEach(alg => {
            const scoreObj = normalizedScores[alg].find(s => s.i === i);
            if (scoreObj) {
                sum += scoreObj.score;
                count++;
            }
        });
        const avgScore = count > 0 ? sum / count : 0;
        combinedScores.push({ i, score: avgScore });
    }
    
    // æ ¹æ®å½“å‰é€‰æ‹©çš„ç®—æ³•å†³å®šæ˜¾ç¤ºå“ªä¸ªåˆ†æ•°
    let displayScores;
    if (currentAlgorithm === 'greedy') {
        displayScores = normalizedScores.greedy;
    } else if (currentAlgorithm === 'heuristic') {
        displayScores = normalizedScores.heuristic;
    } else if (currentAlgorithm === 'entropy') {
        displayScores = normalizedScores.entropy;
    } else if (currentAlgorithm === 'comprehensive') {
        displayScores = normalizedScores.comprehensive;
    } else {
        // å¦‚æœé€‰æ‹©åŠ¨æ€åˆ‡æ¢ï¼Œæ˜¾ç¤ºç»¼åˆåˆ†æ•°
        displayScores = combinedScores;
    }
    
    // æ›´æ–°ç®—æ³•ä¸‹æ‹‰èœå•çš„å‘¼å¸ç¯ç‰¹æ•ˆ
    algorithmSelect.classList.remove('algorithm-pulse');
    // å¦‚æœå¯ç”¨äº†æ™ºèƒ½è‡ªåŠ¨åˆ‡æ¢ï¼Œä¸ºæ¨èç®—æ³•æ·»åŠ å‘¼å¸ç¯
    if (state.autoAlgorithm) {
        algorithmSelect.classList.add('algorithm-pulse');
    }
    
    // æ›´æ–°æ˜¾ç¤º
    for (let i = 0; i < 49; i++) {
        const el = document.getElementById(`cell-${i}`);
        el.classList.remove('best', 'good', 'combined-best');
        if (state.grid[i]) continue;
        
        // æ˜¾ç¤ºå½“å‰ç®—æ³•çš„å½’ä¸€åŒ–åˆ†æ•°
        const scoreObj = displayScores.find(s => s.i === i);
        if (scoreObj) {
            document.getElementById(`s-${i}`).innerText = scoreObj.score.toFixed(1);
        } else {
            document.getElementById(`s-${i}`).innerText = '0';
        }
    }

    // æ ‡è®°æœ€ä½³æ ¼å­ï¼ˆåŸºäºå½“å‰æ˜¾ç¤ºç®—æ³•ï¼‰
    if(displayScores.length > 0){
        const max = Math.max(...displayScores.map(s => s.score));
        // ç¡®ä¿maxæ˜¯æœ‰æ•ˆçš„æ•°å­—
        if (isFinite(max) && max > 0) {
            displayScores.forEach(s => {
                if(s.score === max) {
                    document.getElementById(`cell-${s.i}`).classList.add('best');
                } else if(s.score > max * 0.8) {
                    document.getElementById(`cell-${s.i}`).classList.add('good');
                }
            });
        }
    }
    
    // é¢å¤–æ ‡è®°è¢«å¤šä¸ªç®—æ³•æ¨èçš„æ ¼å­
    // è®¡ç®—æ¯ä¸ªæ ¼å­è¢«æ¨èçš„ç¨‹åº¦ï¼ˆåœ¨å½’ä¸€åŒ–åˆ†æ•°ä¸­æ’åå‰3ï¼‰
    const recommendationCount = Array(49).fill(0);
    Object.keys(normalizedScores).forEach(alg => {
        const algScores = normalizedScores[alg];
        // æŒ‰åˆ†æ•°æ’åº
        const sorted = [...algScores].sort((a, b) => b.score - a.score);
        // å–å‰3å
        const top3 = sorted.slice(0, 3);
        top3.forEach(s => {
            recommendationCount[s.i]++;
        });
    });
    
    // æ ‡è®°è¢«è‡³å°‘2ä¸ªç®—æ³•æ¨èçš„æ ¼å­
    for (let i = 0; i < 49; i++) {
        if (state.grid[i]) continue;
        if (recommendationCount[i] >= 2) {
            document.getElementById(`cell-${i}`).classList.add('combined-best');
        }
    }

    if (unopened === 0 && state.clicks > 0) {
        document.getElementById('winOverlay').style.display = 'flex';
        document.getElementById('winMessage').innerText = `å·²é”å®šå…¨å›¾åæ ‡ï¼æœ¬è½®å…±åé¦ˆ ${state.clicks} æ¬¡ã€‚`;
        localStorage.removeItem(STORAGE_KEY);
    }
    
    // æ›´æ–°çŠ¶æ€æ ï¼Œæ˜¾ç¤ºé˜¶æ®µå’Œæ¨èç®—æ³•
    const algorithmDisplay = state.autoAlgorithm ? 'æ™ºèƒ½' : currentAlgorithm;
    let scoreType = '';
    if (currentAlgorithm === 'auto' || state.autoAlgorithm) {
        scoreType = ' (ç»¼åˆè¯„åˆ†)';
    } else {
        scoreType = ' (å½’ä¸€åŒ–)';
    }
    const statusText = window.innerWidth <= 768 
        ? `å‰©ä½™:${unopened} é˜¶æ®µ:${stage} ç®—æ³•:${algorithmDisplay}`
        : `å‰©ä½™: ${unopened} | é˜¶æ®µ: ${stage} | ç®—æ³•: ${algorithmDisplay}${scoreType} | ç‚¹å‡»: ${state.clicks}`;
    document.getElementById('statusBar').innerText = statusText;
    
    // æ·»åŠ è¯´æ˜æ–‡æœ¬
    const hasCombinedBest = document.querySelector('.cell.combined-best');
    if (hasCombinedBest) {
        document.getElementById('statusBar').innerText += ' | ç»¿æ¡†:å¤šç®—æ³•æ¨è';
    }
    saveState();
}

function runBatchSimulation() {
    const iterations = parseInt(document.getElementById('simIterations').value) || 1000;
    
    // ç¡®å®šå®é™…ä½¿ç”¨çš„ç®—æ³•ï¼šå¦‚æœå½“å‰ç®—æ³•æ˜¯'auto'æˆ–å¯ç”¨äº†è‡ªåŠ¨åˆ‡æ¢ï¼Œåˆ™æ ¹æ®é˜¶æ®µé€‰æ‹©ç®—æ³•
    let actualAlgorithm = state.currentAlgorithm;
    let displayAlgorithm = actualAlgorithm; // ç”¨äºæ˜¾ç¤ºçš„ç®—æ³•åç§°
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦åŠ¨æ€åˆ‡æ¢ï¼ˆä½¿ç”¨å¸¦æ»åçš„é˜¶æ®µåˆ¤æ–­ï¼‰
    if (actualAlgorithm === 'auto' || state.autoAlgorithm) {
        // è®¡ç®—æœªå¼€å¯æ ¼å­æ•°
        let unopened = 0;
        for (let i = 0; i < 49; i++) {
            if (!state.grid[i]) unopened++;
        }
        
        // ä½¿ç”¨ä¸updateAnalysisç›¸åŒçš„æ»åé€»è¾‘
        // åˆ¤æ–­é˜¶æ®µ
        let stageForAuto;
        if (unopened > 37) {
            stageForAuto = "å‰æœŸ";
        } else if (unopened > 35 && window.lastStage === "å‰æœŸ") {
            stageForAuto = "å‰æœŸ";
        } else if (unopened >= 17) {
            stageForAuto = "ä¸­æœŸ";
        } else if (unopened >= 15 && window.lastStage === "ä¸­æœŸ") {
            stageForAuto = "ä¸­æœŸ";
        } else if (unopened >= 13) {
            stageForAuto = "åæœŸ";
        } else {
            stageForAuto = "æœ«æœŸ";
        }
        
        // æ ¹æ®é˜¶æ®µé€‰æ‹©ç®—æ³•
        if (stageForAuto === "å‰æœŸ") {
            actualAlgorithm = 'heuristic';
        } else if (stageForAuto === "ä¸­æœŸ") {
            actualAlgorithm = 'greedy';
        } else {
            actualAlgorithm = 'entropy';
        }
        
        // æ˜¾ç¤ºæ—¶ä½¿ç”¨'åŠ¨æ€åˆ‡æ¢'
        displayAlgorithm = 'åŠ¨æ€åˆ‡æ¢';
    } else {
        // æ ¹æ®ç®—æ³•å€¼è®¾ç½®æ˜¾ç¤ºåç§°
        if (actualAlgorithm === 'greedy') {
            displayAlgorithm = 'è´ªå¿ƒç®—æ³•';
        } else if (actualAlgorithm === 'heuristic') {
            displayAlgorithm = 'å¸¦æƒå¯å‘';
        } else if (actualAlgorithm === 'entropy') {
            displayAlgorithm = 'ç†µå‡ç®—æ³•';
        } else if (actualAlgorithm === 'comprehensive') {
            displayAlgorithm = 'ç»¼åˆæ¨è';
        }
    }
    
    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    const resultsDiv = document.getElementById('simResults');
    const contentDiv = document.getElementById('simResultsContent');
    resultsDiv.style.display = 'block';
    contentDiv.innerHTML = '<p>æ­£åœ¨è¿è¡Œæ¨¡æ‹Ÿï¼Œè¯·ç¨å€™...</p>';
    
    // ä½¿ç”¨ setTimeout é¿å…é˜»å¡ UI
    setTimeout(() => {
        try {
            // è¿è¡Œå½“å‰ç®—æ³•ï¼ˆä½¿ç”¨å®é™…ç®—æ³•ï¼‰
            const currentResults = runSimulation(actualAlgorithm, iterations);
            // è¿è¡ŒåŸºç¡€è´ªå¿ƒç®—æ³•ä½œä¸ºå¯¹æ¯”
            const greedyResults = runSimulation('greedy', iterations);
        
        // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        const calcStats = (arr) => {
            const mean = arr.reduce((a,b) => a + b, 0) / arr.length;
            const variance = arr.reduce((a,b) => a + Math.pow(b - mean, 2), 0) / arr.length;
            const std = Math.sqrt(variance);
            return { mean, variance, std };
        };
        
        const currentStats = calcStats(currentResults);
        const greedyStats = calcStats(greedyResults);
        
        // è®¡ç®—å¼€å±€æœ€ä¼˜è§£çƒ­åŠ›åˆ†å¸ƒï¼ˆç¬¬ä¸€è½®æ¨¡æ‹Ÿçš„ç¬¬ä¸€ä¸ªé€‰æ‹©ï¼‰
        // æˆ‘ä»¬è¿è¡Œä¸€æ¬¡æ¨¡æ‹Ÿï¼Œè®°å½•æ¯ä¸ªæ ¼å­è¢«é€‰ä¸ºç¬¬ä¸€ä¸ªé€‰æ‹©çš„æ¬¡æ•°
        const heatmap = Array(49).fill(0);
        const sampleSize = Math.min(100, iterations);
        for (let i = 0; i < sampleSize; i++) {
            // åˆ›å»ºä¸€ä¸ªæ–°çš„æ¨¡æ‹Ÿï¼Œä½†åªè®°å½•ç¬¬ä¸€æ­¥
            const grid = Array(49).fill(false);
            let currentMisses = 0;
            // åŠ¨æ€æ¦‚ç‡è°ƒæ•´ï¼ˆä¸chooseEventTypeä¸€è‡´ï¼‰
            let adjustedProbs = [...state.probs];
            if (state.enablePity && currentMisses >= state.pityStart) {
                const progress = Math.min((currentMisses - state.pityStart + 1) / (state.pityMax - state.pityStart + 1), 1.0);
                
                // å¦‚æœè¾¾åˆ°æœ€å¤§ä¿åº•æ¬¡æ•°ï¼Œç±»å‹1çš„æ¦‚ç‡ä¸º0
                if (currentMisses >= state.pityMax) {
                    adjustedProbs[0] = 0;
                    // å…¶ä»–ç±»å‹çš„æ¦‚ç‡æŒ‰åŸå§‹æ¯”ä¾‹åˆ†é…
                    const otherTotal = state.probs.slice(1).reduce((a, b) => a + b, 0);
                    for (let j = 1; j < 7; j++) {
                        adjustedProbs[j] = (state.probs[j] / otherTotal) * 100;
                    }
                } else {
                    // é€æ­¥è°ƒæ•´æ¦‚ç‡
                    const type1Reduction = 0.5 * progress;
                    adjustedProbs[0] = state.probs[0] * (1 - type1Reduction);
                    
                    // å°†å‡å°‘çš„æ¦‚ç‡åˆ†é…åˆ°å…¶ä»–ç±»å‹
                    const reductionAmount = state.probs[0] * type1Reduction;
                    const otherTotal = state.probs.slice(1).reduce((a, b) => a + b, 0);
                    
                    for (let j = 1; j < 7; j++) {
                        adjustedProbs[j] = state.probs[j] + (reductionAmount * (state.probs[j] / otherTotal));
                    }
                }
                
                // ç¡®ä¿æ€»å’Œä¸º100
                const total = adjustedProbs.reduce((a, b) => a + b, 0);
                if (total > 0) {
                    for (let j = 0; j < 7; j++) {
                        adjustedProbs[j] = (adjustedProbs[j] * 100) / total;
                    }
                }
            }
            const p = adjustedProbs.map(v => v / 100);
            
            // å¯¹äºçƒ­åŠ›å›¾ï¼Œæˆ‘ä»¬éœ€è¦æ ¹æ®å¼€å±€çŠ¶æ€é‡æ–°è®¡ç®—ç®—æ³•
            // å¼€å±€æ—¶æ‰€æœ‰æ ¼å­éƒ½æœªå¼€å¯ï¼Œæ‰€ä»¥æœªå¼€å¯æ ¼å­æ•°ä¸º49
            let heatmapAlgorithm = actualAlgorithm;
            if (heatmapAlgorithm === 'auto' || state.autoAlgorithm) {
                // å¼€å±€æ—¶æœªå¼€å¯æ ¼å­æ•°ä¸º49ï¼Œå¤§äº35ï¼Œæ‰€ä»¥ä½¿ç”¨heuristic
                heatmapAlgorithm = 'heuristic';
            }
            
            let scores;
            if (heatmapAlgorithm === 'greedy') {
                scores = Algorithms.greedy(p, grid);
            } else if (heatmapAlgorithm === 'heuristic') {
                scores = Algorithms.heuristic(p, grid, state.heuristicWeight);
            } else if (heatmapAlgorithm === 'entropy') {
                scores = Algorithms.entropy(p, grid);
            } else if (heatmapAlgorithm === 'comprehensive') {
                scores = Algorithms.comprehensive(p, grid, state.heuristicWeight);
            }
            
            if (scores.length > 0) {
                let maxScore = -Infinity;
                let bestIndices = [];
                for (const s of scores) {
                    if (s.score > maxScore) {
                        maxScore = s.score;
                        bestIndices = [s.i];
                    } else if (s.score === maxScore) {
                        bestIndices.push(s.i);
                    }
                }
                if (bestIndices.length > 0) {
                    // éšæœºé€‰æ‹©ä¸€ä¸ªæœ€é«˜åˆ†æ ¼å­
                    const randomIndex = Math.floor(Math.random() * bestIndices.length);
                    const bestIdx = bestIndices[randomIndex];
                    heatmap[bestIdx]++;
                }
            }
        }
        
        // ç”Ÿæˆç»“æœ HTML
        let html = `
            <div style="background:#f8f9fa; padding:10px; border-radius:8px; margin-bottom:10px;">
                <h5 style="margin:0 0 8px 0;">å¯¹æ¯”ç»“æœ (${iterations} æ¬¡æ¨¡æ‹Ÿ)</h5>
                <table style="width:100%; font-size:11px; border-collapse:collapse;">
                    <tr>
                        <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">æŒ‡æ ‡</th>
                        <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">å½“å‰ç®—æ³• (${displayAlgorithm})</th>
                        <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">åŸºç¡€è´ªå¿ƒ</th>
                    </tr>
                    <tr>
                        <td style="padding:4px; border-bottom:1px solid #eee;">å¹³å‡ç‚¹å‡»æ¬¡æ•°</td>
                        <td style="padding:4px; border-bottom:1px solid #eee;">${currentStats.mean.toFixed(2)}</td>
                        <td style="padding:4px; border-bottom:1px solid #eee;">${greedyStats.mean.toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td style="padding:4px; border-bottom:1px solid #eee;">æ–¹å·®</td>
                        <td style="padding:4px; border-bottom:1px solid #eee;">${currentStats.variance.toFixed(2)}</td>
                        <td style="padding:4px; border-bottom:1px solid #eee;">${greedyStats.variance.toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td style="padding:4px; border-bottom:1px solid #eee;">æ ‡å‡†å·®</td>
                        <td style="padding:4px; border-bottom:1px solid #eee;">${currentStats.std.toFixed(2)}</td>
                        <td style="padding:4px; border-bottom:1px solid #eee;">${greedyStats.std.toFixed(2)}</td>
                    </tr>
                </table>
            </div>
            <div style="background:#f8f9fa; padding:10px; border-radius:8px;">
                <h5 style="margin:0 0 8px 0;">å¼€å±€æœ€ä¼˜è§£çƒ­åŠ›åˆ†å¸ƒ (å‰${sampleSize}æ¬¡æ¨¡æ‹Ÿ)</h5>
                <div style="display:grid; grid-template-columns:repeat(7, 1fr); gap:2px;">
        `;
        for (let i = 0; i < 49; i++) {
            const intensity = Math.min(100, (heatmap[i] / sampleSize) * 100);
            html += `<div style="background:hsl(200, 70%, ${100 - intensity}%); text-align:center; font-size:8px; padding:4px;">${heatmap[i]}</div>`;
        }
        html += `
                </div>
                <p style="font-size:10px; color:#666; margin-top:5px;">æ•°å­—è¡¨ç¤ºè¢«é€‰ä¸ºç¬¬ä¸€æ­¥çš„æ¬¡æ•°</p>
            </div>
        `;
        
            contentDiv.innerHTML = html;
        } catch (error) {
            console.error('æ¨¡æ‹Ÿè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error);
            contentDiv.innerHTML = `<p style="color:red;">æ¨¡æ‹Ÿè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: ${error.message}</p>`;
        }
    }, 10);
}

function confirmReset() {
    if(confirm("ç¡®å®šé‡ç½®å—ï¼Ÿ")){
        state = JSON.parse(JSON.stringify(defaultData));
        localStorage.removeItem(STORAGE_KEY);
        document.getElementById('winOverlay').style.display = 'none';
        init();
    }
}
window.onload = init;
</script>
</body>
</html>
