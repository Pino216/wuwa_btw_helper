<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é¸£æ½®Â·è¸æ½®æ¢å†ç®—æ³•åŠ©æ‰‹ ğŸ¤–</title>
    <style>
        :root {
            --bg: #f4f7f6;
            --primary: #2ed573;
            --danger: #ff4757;
            --accent: #1e90ff;
            --card-bg: #ffffff;
            --text-main: #333333;
            --text-sub: #666666;
            --grid-gap: 6px;
        }

        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
            color: var(--text-main);
            min-height: 100vh;
        }

        /* é¡¶éƒ¨æ ‡é¢˜ */
        .header { text-align: center; margin-bottom: 20px; width: 100%; }
        .header h2 { margin: 0; font-size: 24px; letter-spacing: 1px; }

        /* æ ¸å¿ƒå¸ƒå±€ */
        .layout {
            display: flex;
            justify-content: center;
            gap: 20px;
            max-width: 1200px;
            width: 100%;
            transition: all 0.4s ease;
        }

        /* --- é…ç½®é¢æ¿ (å“åº”å¼) --- */
        .config-panel {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
            width: 280px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: sticky;
            top: 20px;
            overflow: hidden;
            z-index: 100;
            flex-shrink: 0;
        }

        .config-content { transition: opacity 0.3s ease; }

        /* ç”µè„‘ç«¯æŠ˜å çŠ¶æ€ */
        .config-panel.collapsed {
            width: 20px;
            padding: 20px 5px;
            background: #eee;
        }
        .config-panel.collapsed .config-content { opacity: 0; pointer-events: none; }

        /* åˆ‡æ¢æŒ‰é’® */
        .toggle-btn {
            position: absolute;
            right: 0; top: 50%;
            transform: translateY(-50%);
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 4px 0 0 4px;
            width: 24px; height: 60px;
            cursor: pointer;
            z-index: 110;
            font-size: 12px;
            display: flex; align-items: center; justify-content: center;
        }

        /* --- ç½‘æ ¼åŒºåŸŸ --- */
        .grid-area { flex: 0 1 auto; display: flex; flex-direction: column; align-items: center; width: 100%; }
        .grid {
            display: grid;
            grid-template-columns: repeat(7, 55px);
            gap: var(--grid-gap);
            background: var(--card-bg);
            padding: 15px;
            border-radius: 16px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.1);
            position: relative;
            z-index: 1;
        }

        /* éšå½¢æ°´å° */
        .grid::after {
            content: "Designed by @Darkå™«æœ¯å®¶";
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) rotate(-30deg);
            font-size: 24px;
            color: rgba(0, 0, 0, 0.04);
            white-space: nowrap;
            pointer-events: none;
            z-index: 10;
        }

        .cell {
            width: 55px; height: 55px;
            background: #f8f9fa;
            border: 1px solid #eee;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            cursor: pointer; border-radius: 8px;
            position: relative;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        .cell:hover:not(.opened) { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0,0,0,0.1); border-color: var(--accent); }
        .cell .coord { font-size: 8px; color: #ccc; position: absolute; top: 2px; left: 4px; }
        .cell .score { font-size: 11px; font-weight: bold; margin-top: 4px; }

        .cell.opened { background: #fff !important; border-color: #f0f0f0; cursor: default; }
        .cell.opened::after { content: 'âœ…'; font-size: 16px; }
        .cell.opened .score, .cell.opened .coord { display: none; }

        .cell.best { background: var(--danger) !important; color: white; z-index: 5; box-shadow: 0 0 15px rgba(255,71,87,0.4); border: none; }
        .cell.good { background: #ffa502 !important; color: white; z-index: 4; border: none; }

        /* å…¶ä»–ç»„ä»¶ */
        .prob-input-group { margin-bottom: 8px; display: flex; align-items: center; justify-content: space-between; font-size: 13px; }
        .prob-input-group input { width: 50px; padding: 4px; border: 1px solid #ddd; border-radius: 4px; text-align: center; }
        .status-bar { margin-top: 15px; padding: 10px; border-radius: 10px; background: #fff; font-size: 13px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); width: 100%; text-align: center; }
        .btn-reset { margin-top: 15px; width: 100%; padding: 12px; background: #2d3436; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; }

        /* æ‰‹æœºç«¯é€‚é… (å…³é”®ä¿®æ”¹) */
        @media screen and (max-width: 768px) {
            .layout { flex-direction: column; align-items: center; }
            .config-panel {
                position: relative; top: 0; width: 90% !important; order: 2;
                margin-top: 20px; padding: 15px; height: auto;
            }
            .config-panel.collapsed {
                height: 45px; width: 90% !important; padding: 10px 15px;
            }
            .toggle-btn {
                right: 0; top: 0; transform: none;
                width: 100%; height: 45px;
                border-radius: 16px 16px 0 0;
                background: rgba(30, 144, 255, 0.1);
                color: var(--accent);
                font-weight: bold;
            }
            .grid {
                grid-template-columns: repeat(7, 11vw);
                gap: 4px;
                padding: 10px;
            }
            .cell { width: 11vw; height: 11vw; }
            .watermark { display: none; }
            .header h2 { font-size: 20px; }
        }

        /* æµ®åŠ¨èœå• */
        #menu { display: none; position: fixed; background: white; border-radius: 12px; box-shadow: 0 15px 50px rgba(0,0,0,0.2); padding: 15px; z-index: 1000; min-width: 180px; }
        .menu-btn { display: block; width: 100%; padding: 10px; margin-bottom: 6px; border: none; background: #f8f9fa; border-radius: 8px; cursor: pointer; text-align: left; font-size: 13px; }
        .menu-btn:hover { background: var(--accent); color: white; }

        .watermark { position: fixed; top: 15px; right: 15px; background: rgba(255,255,255,0.9); padding: 8px 12px; border-radius: 10px; border-left: 4px solid var(--accent); box-shadow: 0 10px 25px rgba(0,0,0,0.1); z-index: 1000; font-size: 12px; }

        /* æ­å–œå¼¹çª— */
        #winOverlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(8px); z-index: 2000;
            flex-direction: column; justify-content: center; align-items: center;
        }
        .win-card { background: #fff; padding: 30px; border-radius: 20px; text-align: center; width: 80%; max-width: 320px; animation: popIn 0.5s ease forwards; }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>

<div class="watermark">
    <b>ğŸ“º Bç«™@Darkå™«æœ¯å®¶</b>
</div>

<div class="header">
    <h2>é¸£æ½®âœ¨è¸æ½®æ¢å†å°åŠ©æ‰‹ ğŸ¤–</h2>
</div>

<div class="layout">
    <div class="config-panel" id="configPanel">
        <button class="toggle-btn" onclick="toggleConfig()" id="toggleBtn">â—€</button>
        <div class="config-content">
            <h3 style="margin-top:0; font-size:16px;">âš™ï¸ æ¦‚ç‡æƒé‡</h3>
            <div id="probInputs"></div>
            <div id="probWarning" style="font-size: 12px; margin: 8px 0;"></div>
            
            <h3 style="margin-top:20px; font-size:16px;">ğŸ¯ ä¿åº•ç³»ç»Ÿ</h3>
            <div style="margin-bottom:10px;">
                <div class="prob-input-group">
                    <label>å¯ç”¨ä¿åº•</label>
                    <input type="checkbox" id="enablePity" onchange="updatePityEnable(this.checked)" style="width:auto;">
                </div>
                <div class="prob-input-group">
                    <label>ä¿åº•èµ·å§‹ (X)</label>
                    <input type="number" id="pityStart" onchange="updatePityStart(this.value)" min="1" max="20">
                </div>
                <div class="prob-input-group">
                    <label>ä¿åº•ä¸Šé™ (Y)</label>
                    <input type="number" id="pityMax" onchange="updatePityMax(this.value)" min="2" max="50">
                </div>
                <div style="font-size:11px; color:#888; margin-top:5px;">
                    å½“å‰æœªè§¦å‘è®¡æ•°: <span id="currentMissesDisplay"></span>
                </div>
            </div>
            
            <h3 style="margin-top:20px; font-size:16px;">ğŸ¤– ç®—æ³•é€‰æ‹©</h3>
            <div style="margin-bottom:10px;">
                <div class="prob-input-group">
                    <label>å½“å‰ç®—æ³•</label>
                    <select id="algorithmSelect" onchange="updateAlgorithm(this.value)" style="width:120px; padding:4px;">
                        <option value="greedy">è´ªå¿ƒç®—æ³•</option>
                        <option value="weighted">å¸¦æƒå¯å‘å¼</option>
                        <option value="entropy">ç†µå‡ç®—æ³•</option>
                    </select>
                </div>
                <div class="prob-input-group" id="weightParamGroup" style="display:none;">
                    <label>å¯å‘å¼æƒé‡ (w)</label>
                    <input type="number" id="heuristicWeight" value="1.0" step="0.1" min="0.1" max="5.0" onchange="updateHeuristicWeight(this.value)" style="width:60px;">
                </div>
            </div>

            <h3 style="margin-top:20px; font-size:16px;">ğŸ§ª æ‰¹é‡æ¨¡æ‹Ÿ</h3>
            <div style="margin-bottom:10px;">
                <div class="prob-input-group">
                    <label>æ¨¡æ‹Ÿæ¬¡æ•°</label>
                    <input type="number" id="simIterations" value="1000" min="10" max="10000" style="width:70px;">
                </div>
                <button class="btn-reset" onclick="runBatchSimulation()" style="margin-top:10px; background:var(--accent);">å¼€å§‹æ‰¹é‡æ¨¡æ‹Ÿ</button>
                <div id="simResults" style="margin-top:15px; font-size:12px; display:none;">
                    <h4 style="margin:0 0 8px 0;">æ¨¡æ‹Ÿç»“æœ</h4>
                    <div id="simResultsContent"></div>
                </div>
            </div>
            
            <button class="btn-reset" onclick="confirmReset()">ğŸ”„ é‡ç½®è¿›åº¦</button>
        </div>
    </div>

    <div class="grid-area">
        <div class="grid" id="grid"></div>
        <div class="status-bar" id="statusBar">â³ ç­‰å¾…æ“ä½œ...</div>
    </div>
</div>

<div id="menu">
    <h4 style="margin:0 0 10px 0; font-size:14px;">âœ¨ è§¦å‘äº‹ä»¶</h4>
    <div id="menuButtons"></div>
    <button class="menu-btn" onclick="closeMenu()" style="background:#eee; text-align:center; margin-top:5px;">å–æ¶ˆ</button>
</div>

<div id="winOverlay">
    <div class="win-card">
        <h2>ğŸ‰ æ¢å†è¾¾æˆï¼</h2>
        <p id="winMessage" style="color:#666; font-size:14px; line-height:1.6;"></p>
        <button onclick="confirmReset()" style="padding: 10px 20px; background: var(--primary); color:white; border:none; border-radius:8px; cursor:pointer; width:100%; font-weight:bold;">å¼€å¯æ–°ä¸€è½® ğŸš€</button>
    </div>
</div>

<script>
const size = 7;
const STORAGE_KEY = 'MC_EVENT_HELPER_V1.2_MOBILE';
const defaultData = {
    grid: Array(size * size).fill(false),
    probs: [33, 14, 14, 7, 18, 13, 1],
    clicks: 0,
    enablePity: true,
    pityStart: 3,
    pityMax: 10,
    currentMisses: 0,
    currentAlgorithm: 'greedy',
    heuristicWeight: 1.0
};

let state = loadState();
let activePos = { r: -1, c: -1 };

// --- é€‚é…ä¸æŠ˜å é€»è¾‘ ---
function toggleConfig() {
    const panel = document.getElementById('configPanel');
    const btn = document.getElementById('toggleBtn');
    const isMobile = window.innerWidth <= 768;

    panel.classList.toggle('collapsed');

    if (panel.classList.contains('collapsed')) {
        btn.innerText = isMobile ? 'ğŸ”½ å±•å¼€é…ç½®å‚æ•°' : 'â–¶';
    } else {
        btn.innerText = isMobile ? 'ğŸ”¼ æ”¶èµ·é…ç½®å‚æ•°' : 'â—€';
    }
}

function loadState() {
    const saved = localStorage.getItem(STORAGE_KEY);
    const loaded = saved ? JSON.parse(saved) : JSON.parse(JSON.stringify(defaultData));
    // ç¡®ä¿æ‰€æœ‰å­—æ®µéƒ½å­˜åœ¨
    return {
        ...JSON.parse(JSON.stringify(defaultData)),
        ...loaded,
        // ç¡®ä¿æ•°ç»„æ˜¯æ–°çš„å¼•ç”¨
        grid: loaded.grid || [...defaultData.grid],
        probs: loaded.probs || [...defaultData.probs],
        clicks: loaded.clicks || 0,
        enablePity: loaded.enablePity !== undefined ? loaded.enablePity : defaultData.enablePity,
        pityStart: loaded.pityStart || defaultData.pityStart,
        pityMax: loaded.pityMax || defaultData.pityMax,
        currentMisses: loaded.currentMisses || 0,
        currentAlgorithm: loaded.currentAlgorithm || defaultData.currentAlgorithm,
        heuristicWeight: loaded.heuristicWeight || defaultData.heuristicWeight
    };
}

function saveState() { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

function init() {
    // æ¸²æŸ“è¾“å…¥æ¡†
    const probContainer = document.getElementById('probInputs');
    probContainer.innerHTML = '';
    const labels = ["ä»…å½“å‰ ğŸ“", "åŒåˆ— â†•ï¸", "åŒè¡Œ â†”ï¸", "åŒè¡ŒåŒåˆ— â•", "åå­— ğŸ’ ", "ä¹å®«æ ¼ ğŸ·", "å…¨å¼€ ğŸŒŸ"];

    labels.forEach((label, i) => {
        const div = document.createElement('div');
        div.className = 'prob-input-group';
        div.innerHTML = `<label>${label}</label><input type="number" id="p${i}" value="${state.probs[i]}" onchange="updateProbs(${i}, this.value)">`;
        probContainer.appendChild(div);
    });

    // æ¸²æŸ“ä¿åº•é…ç½®
    document.getElementById('enablePity').checked = state.enablePity;
    document.getElementById('pityStart').value = state.pityStart;
    document.getElementById('pityMax').value = state.pityMax;
    document.getElementById('currentMissesDisplay').textContent = state.currentMisses;
    
    // æ¸²æŸ“ç®—æ³•é€‰æ‹©
    document.getElementById('algorithmSelect').value = state.currentAlgorithm;
    document.getElementById('heuristicWeight').value = state.heuristicWeight;
    // æ ¹æ®ç®—æ³•æ˜¾ç¤º/éšè—æƒé‡å‚æ•°
    const weightGroup = document.getElementById('weightParamGroup');
    weightGroup.style.display = state.currentAlgorithm === 'weighted' ? 'flex' : 'none';

    // æ¸²æŸ“ç½‘æ ¼
    const gridEl = document.getElementById('grid');
    gridEl.innerHTML = '';
    for (let i = 0; i < 49; i++) {
        const r = Math.floor(i / 7), c = i % 7;
        const cell = document.createElement('div');
        cell.className = 'cell' + (state.grid[i] ? ' opened' : '');
        cell.id = `cell-${i}`;
        cell.innerHTML = `<span class="coord">${r+1},${c+1}</span><span class="score" id="s-${i}">0</span>`;
        cell.onclick = (e) => showMenu(r, c, e);
        gridEl.appendChild(cell);
    }

    // æ¸²æŸ“èœå•æŒ‰é’®
    const menuBtns = document.getElementById('menuButtons');
    menuBtns.innerHTML = '';
    labels.forEach((label, i) => {
        const btn = document.createElement('button');
        btn.className = 'menu-btn';
        btn.innerText = label;
        btn.onclick = () => applyEvent(i + 1);
        menuBtns.appendChild(btn);
    });
    updateAnalysis();
}

// --- éŸ³æ•ˆç³»ç»Ÿ ---
function playEffect(type) {
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const now = audioCtx.currentTime;
    const osc = (f, s, d, w='sine') => {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = w; o.frequency.setValueAtTime(f, s);
        g.gain.setValueAtTime(0.08, s); g.gain.exponentialRampToValueAtTime(0.0001, s + d);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(s); o.stop(s + d);
    };
    if(type === 1) osc(880, now, 0.1);
    else if(type === 7) [523, 659, 783, 1046].forEach((f, i) => osc(f, now + i*0.1, 0.5));
    else osc(587, now, 0.15, 'triangle');
}

// --- é€»è¾‘å¤„ç† ---
function updateProbs(i, val) { state.probs[i] = parseInt(val) || 0; updateAnalysis(); }
function updatePityEnable(checked) { state.enablePity = checked; updateAnalysis(); }
function updatePityStart(val) { state.pityStart = parseInt(val) || 3; updateAnalysis(); }
function updatePityMax(val) { state.pityMax = parseInt(val) || 10; updateAnalysis(); }
function updateAlgorithm(val) {
    state.currentAlgorithm = val;
    const weightGroup = document.getElementById('weightParamGroup');
    weightGroup.style.display = val === 'weighted' ? 'flex' : 'none';
    updateAnalysis();
}
function updateHeuristicWeight(val) {
    state.heuristicWeight = parseFloat(val) || 1.0;
    updateAnalysis();
}

function showMenu(r, c, e) {
    if (state.grid[r * 7 + c]) return;
    activePos = { r, c };
    const menu = document.getElementById('menu');
    menu.style.display = 'block';
    menu.style.left = Math.min(e.pageX, window.innerWidth - 200) + 'px';
    menu.style.top = Math.min(e.pageY, window.innerHeight - 300) + 'px';
}

function closeMenu() { document.getElementById('menu').style.display = 'none'; }

function applyEvent(type) {
    playEffect(type);
    const { r, c } = activePos;
    const mark = (row, col) => {
        if (row >= 0 && row < 7 && col >= 0 && col < 7) {
            const idx = row * 7 + col;
            state.grid[idx] = true;
            document.getElementById(`cell-${idx}`).classList.add('opened');
        }
    };
    if (type === 1) {
        mark(r, c);
        state.currentMisses++;
    } else {
        // ç±»å‹ 2-7
        if (type === 2) for(let i=0; i<7; i++) mark(i, c);
        else if (type === 3) for(let i=0; i<7; i++) mark(r, i);
        else if (type === 4) { for(let i=0; i<7; i++) { mark(i, c); mark(r, i); } }
        else if (type === 5) { mark(r, c); mark(r-1,c); mark(r+1,c); mark(r,c-1); mark(r,c+1); }
        else if (type === 6) { for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) mark(r+i, c+j); }
        else if (type === 7) { state.grid.fill(true); init(); }
        state.currentMisses = 0;
    }

    state.clicks++;
    closeMenu();
    updateAnalysis();
}

// ç®—æ³•å¯¹è±¡
const Algorithms = {
    // è´ªå¿ƒç®—æ³•ï¼šä½¿ç”¨ç°æœ‰é€»è¾‘
    greedy: function(p, grid) {
        let scores = [];
        for (let i = 0; i < 49; i++) {
            const r = Math.floor(i / 7), c = i % 7;
            if (grid[i]) continue;
            let gain = p[0] * 1;
            let rg=0, cg=0, comb=0, cross=0, box=0;
            for(let j=0; j<7; j++) {
                if(!grid[r*7+j]) { rg++; comb++; }
                if(!grid[j*7+c]) { cg++; if(j!==r) comb++; }
            }
            gain += p[1]*cg + p[2]*rg + p[3]*comb;
            [[0,0],[1,0],[-1,0],[0,1],[0,-1]].forEach(o => {
                let nr=r+o[0], nc=c+o[1];
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) cross++;
            });
            for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
                let nr=r+dr, nc=c+dc;
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) box++;
            }
            gain += p[4]*cross + p[5]*box + p[6]*(grid.filter(v=>!v).length);
            scores.push({ i, score: gain });
        }
        return scores;
    },
    
    // å¸¦æƒå¯å‘å¼ï¼šf(n) = g(n) + w * h(n)
    weighted: function(p, grid, weight) {
        let scores = [];
        // è®¡ç®—æ¯ä¸ªæ ¼å­çš„ g(n)ï¼ˆåŸºç¡€æ”¶ç›Šï¼‰
        for (let i = 0; i < 49; i++) {
            const r = Math.floor(i / 7), c = i % 7;
            if (grid[i]) continue;
            let g = 0;
            // åŸºç¡€æ”¶ç›Šè®¡ç®—ï¼ˆä¸è´ªå¿ƒç›¸åŒï¼‰
            let rg=0, cg=0, comb=0, cross=0, box=0;
            for(let j=0; j<7; j++) {
                if(!grid[r*7+j]) { rg++; comb++; }
                if(!grid[j*7+c]) { cg++; if(j!==r) comb++; }
            }
            g = p[0]*1 + p[1]*cg + p[2]*rg + p[3]*comb;
            [[0,0],[1,0],[-1,0],[0,1],[0,-1]].forEach(o => {
                let nr=r+o[0], nc=c+o[1];
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) cross++;
            });
            for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
                let nr=r+dr, nc=c+dc;
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) box++;
            }
            g += p[4]*cross + p[5]*box + p[6]*(grid.filter(v=>!v).length);
            
            // å¯å‘å¼å‡½æ•° h(n)ï¼šæ½œåœ¨è¦†ç›–ç‡
            // è®¡ç®—è¯¥æ ¼å­å‘¨å›´æœªå¼€å¯æ ¼å­çš„æ•°é‡ï¼ˆ3x3åŒºåŸŸï¼‰
            let h = 0;
            for(let dr=-1;dr<=1;dr++) {
                for(let dc=-1;dc<=1;dc++) {
                    let nr=r+dr, nc=c+dc;
                    if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) {
                        h++;
                    }
                }
            }
            // å½’ä¸€åŒ– h åˆ° 0-1 èŒƒå›´ï¼ˆæœ€å¤§9ï¼‰
            h = h / 9;
            
            const f = g + weight * h;
            scores.push({ i, score: f });
        }
        return scores;
    },
    
    // ç†µå‡ç®—æ³•ï¼šä¼˜å…ˆåˆ†æ•£æœªå¼€å¯æ ¼å­ç°‡
    entropy: function(p, grid) {
        let scores = [];
        // é¦–å…ˆï¼Œæ‰¾å‡ºæ‰€æœ‰æœªå¼€å¯æ ¼å­çš„ç°‡
        // ä½¿ç”¨ç®€å•çš„è¿é€šåˆ†é‡æ ‡è®°ï¼ˆ4è¿é€šï¼‰
        let visited = Array(49).fill(false);
        let clusters = [];
        for (let i = 0; i < 49; i++) {
            if (!grid[i] && !visited[i]) {
                let stack = [i];
                let cluster = [];
                while (stack.length > 0) {
                    let idx = stack.pop();
                    if (visited[idx]) continue;
                    visited[idx] = true;
                    cluster.push(idx);
                    let r = Math.floor(idx / 7), c = idx % 7;
                    // ä¸Šä¸‹å·¦å³
                    let neighbors = [
                        [r-1, c], [r+1, c], [r, c-1], [r, c+1]
                    ];
                    for (let [nr, nc] of neighbors) {
                        if (nr>=0 && nr<7 && nc>=0 && nc<7) {
                            let nIdx = nr*7 + nc;
                            if (!grid[nIdx] && !visited[nIdx]) {
                                stack.push(nIdx);
                            }
                        }
                    }
                }
                clusters.push(cluster);
            }
        }
        
        // è®¡ç®—æ¯ä¸ªæ ¼å­çš„ç†µå‡åˆ†æ•°
        for (let i = 0; i < 49; i++) {
            const r = Math.floor(i / 7), c = i % 7;
            if (grid[i]) continue;
            // åŸºç¡€æ”¶ç›Š g(n)
            let g = 0;
            let rg=0, cg=0, comb=0, cross=0, box=0;
            for(let j=0; j<7; j++) {
                if(!grid[r*7+j]) { rg++; comb++; }
                if(!grid[j*7+c]) { cg++; if(j!==r) comb++; }
            }
            g = p[0]*1 + p[1]*cg + p[2]*rg + p[3]*comb;
            [[0,0],[1,0],[-1,0],[0,1],[0,-1]].forEach(o => {
                let nr=r+o[0], nc=c+o[1];
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) cross++;
            });
            for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
                let nr=r+dr, nc=c+dc;
                if(nr>=0&&nr<7&&nc>=0&&nc<7 && !grid[nr*7+nc]) box++;
            }
            g += p[4]*cross + p[5]*box + p[6]*(grid.filter(v=>!v).length);
            
            // ç†µå‡åˆ†æ•°ï¼šé€‰æ‹©è¯¥æ ¼å­åï¼Œå‰©ä½™ç°‡çš„æ•°é‡å˜åŒ–
            // æ¨¡æ‹Ÿé€‰æ‹©è¯¥æ ¼å­ï¼ˆä¸´æ—¶æ ‡è®°ä¸ºå¼€å¯ï¼‰
            let tempGrid = [...grid];
            tempGrid[i] = true;
            // é‡æ–°è®¡ç®—ç°‡çš„æ•°é‡
            let tempVisited = Array(49).fill(false);
            let newClusters = 0;
            for (let j = 0; j < 49; j++) {
                if (!tempGrid[j] && !tempVisited[j]) {
                    newClusters++;
                    // ç®€å•æ ‡è®°ï¼Œä¸å±•å¼€
                    let stack = [j];
                    while (stack.length > 0) {
                        let idx = stack.pop();
                        if (tempVisited[idx]) continue;
                        tempVisited[idx] = true;
                        let rr = Math.floor(idx / 7), cc = idx % 7;
                        let neighbors = [
                            [rr-1, cc], [rr+1, cc], [rr, cc-1], [rr, cc+1]
                        ];
                        for (let [nr, nc] of neighbors) {
                            if (nr>=0 && nr<7 && nc>=0 && nc<7) {
                                let nIdx = nr*7 + nc;
                                if (!tempGrid[nIdx] && !tempVisited[nIdx]) {
                                    stack.push(nIdx);
                                }
                            }
                        }
                    }
                }
            }
            // åŸå§‹ç°‡æ•°é‡
            let originalClusters = clusters.length;
            // ç†µå‡ = åŸå§‹ç°‡æ•°é‡ - æ–°ç°‡æ•°é‡ï¼ˆæˆ‘ä»¬å¸Œæœ›å‡å°‘ç°‡çš„æ•°é‡ï¼‰
            let entropyReduction = originalClusters - newClusters;
            // åˆ†æ•° = g(n) + ç†µå‡ï¼ˆå½’ä¸€åŒ–ï¼‰
            const score = g + entropyReduction * 0.5; // è°ƒæ•´ç³»æ•°
            scores.push({ i, score: score });
        }
        return scores;
    }
};

// æ¨¡æ‹Ÿå•ä¸ªæ¸¸æˆç›´åˆ°å®Œæˆï¼Œè¿”å›ç‚¹å‡»æ¬¡æ•°
function runSimulation(algorithmType, iterations = 1000) {
    // å¤åˆ¶å½“å‰çŠ¶æ€è®¾ç½®
    const baseProbs = [...state.probs];
    const enablePity = state.enablePity;
    const pityStart = state.pityStart;
    const pityMax = state.pityMax;
    const heuristicWeight = state.heuristicWeight;
    
    // æ¨¡æ‹Ÿå‡½æ•°
    function simulateOneGame() {
        let grid = Array(49).fill(false);
        let clicks = 0;
        let currentMisses = 0;
        
        // è¾…åŠ©å‡½æ•°ï¼šåº”ç”¨äº‹ä»¶
        const applyEventToGrid = (type, r, c, grid) => {
            const mark = (row, col) => {
                if (row >= 0 && row < 7 && col >= 0 && col < 7) {
                    const idx = row * 7 + col;
                    grid[idx] = true;
                }
            };
            if (type === 1) {
                mark(r, c);
                currentMisses++;
            } else {
                if (type === 2) for(let i=0; i<7; i++) mark(i, c);
                else if (type === 3) for(let i=0; i<7; i++) mark(r, i);
                else if (type === 4) { for(let i=0; i<7; i++) { mark(i, c); mark(r, i); } }
                else if (type === 5) { mark(r, c); mark(r-1,c); mark(r+1,c); mark(r,c-1); mark(r,c+1); }
                else if (type === 6) { for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) mark(r+i, c+j); }
                else if (type === 7) { grid.fill(true); }
                currentMisses = 0;
            }
            return grid;
        };
        
        // é€‰æ‹©äº‹ä»¶ç±»å‹ï¼ˆè€ƒè™‘ä¿åº•ï¼‰
        const chooseEventType = () => {
            // åŠ¨æ€æ¦‚ç‡è°ƒæ•´
            let adjustedProbs = [...baseProbs];
            if (enablePity && currentMisses >= pityStart) {
                const progress = Math.min((currentMisses - pityStart + 1) / (pityMax - pityStart + 1), 1.0);
                const factor = 1 + 0.5 * progress;
                for (let i = 0; i < 6; i++) {
                    adjustedProbs[i] = baseProbs[i] * factor;
                }
                const total = adjustedProbs.reduce((a, b) => a + b, 0);
                for (let i = 0; i < 7; i++) {
                    adjustedProbs[i] = (adjustedProbs[i] * 100) / total;
                }
            }
            // å½’ä¸€åŒ–
            const sum = adjustedProbs.reduce((a, b) => a + b, 0);
            const normalized = adjustedProbs.map(p => p / sum);
            // éšæœºé€‰æ‹©
            const rand = Math.random();
            let accum = 0;
            for (let i = 0; i < 7; i++) {
                accum += normalized[i];
                if (rand <= accum) return i + 1;
            }
            return 7;
        };
        
        // é€‰æ‹©æœ€ä½³æ ¼å­
        const chooseBestCell = (grid, algorithmType) => {
            // åŠ¨æ€æ¦‚ç‡è°ƒæ•´ï¼ˆç”¨äºè®¡ç®—åˆ†æ•°ï¼‰
            let adjustedProbs = [...baseProbs];
            if (enablePity && currentMisses >= pityStart) {
                const progress = Math.min((currentMisses - pityStart + 1) / (pityMax - pityStart + 1), 1.0);
                const factor = 1 + 0.5 * progress;
                for (let i = 0; i < 6; i++) {
                    adjustedProbs[i] = baseProbs[i] * factor;
                }
                const total = adjustedProbs.reduce((a, b) => a + b, 0);
                for (let i = 0; i < 7; i++) {
                    adjustedProbs[i] = (adjustedProbs[i] * 100) / total;
                }
            }
            const p = adjustedProbs.map(v => v / 100);
            
            let scores;
            if (algorithmType === 'greedy') {
                scores = Algorithms.greedy(p, grid);
            } else if (algorithmType === 'weighted') {
                scores = Algorithms.weighted(p, grid, heuristicWeight);
            } else if (algorithmType === 'entropy') {
                scores = Algorithms.entropy(p, grid);
            } else {
                scores = Algorithms.greedy(p, grid);
            }
            
            // æ‰¾åˆ°æœ€é«˜åˆ†
            if (scores.length === 0) return null;
            let maxScore = -Infinity;
            // æ”¶é›†æ‰€æœ‰æœ€é«˜åˆ†çš„æ ¼å­ç´¢å¼•
            let bestIndices = [];
            for (const s of scores) {
                if (s.score > maxScore) {
                    maxScore = s.score;
                    bestIndices = [s.i];
                } else if (s.score === maxScore) {
                    bestIndices.push(s.i);
                }
            }
            if (bestIndices.length === 0) return null;
            // éšæœºé€‰æ‹©ä¸€ä¸ªæœ€é«˜åˆ†æ ¼å­
            const randomIndex = Math.floor(Math.random() * bestIndices.length);
            const bestIdx = bestIndices[randomIndex];
            return { r: Math.floor(bestIdx / 7), c: bestIdx % 7 };
        };
        
        // ä¸»å¾ªç¯
        while (grid.some(cell => !cell)) {
            const best = chooseBestCell(grid, algorithmType);
            if (!best) break;
            const eventType = chooseEventType();
            applyEventToGrid(eventType, best.r, best.c, grid);
            clicks++;
        }
        return clicks;
    }
    
    // è¿è¡Œå¤šæ¬¡æ¨¡æ‹Ÿ
    const results = [];
    for (let i = 0; i < iterations; i++) {
        results.push(simulateOneGame());
    }
    return results;
}

function updateAnalysis() {
    let unopened = 0;
    let scores = [];
    
    // åŠ¨æ€æ¦‚ç‡è°ƒæ•´
    let adjustedProbs = [...state.probs];
    if (state.enablePity && state.currentMisses >= state.pityStart) {
        const progress = Math.min((state.currentMisses - state.pityStart + 1) / (state.pityMax - state.pityStart + 1), 1.0);
        const factor = 1 + 0.5 * progress; // æœ€å¤§å¢åŠ 50%
        
        // åªè°ƒæ•´å‰6ä¸ªæƒé‡
        for (let i = 0; i < 6; i++) {
            adjustedProbs[i] = state.probs[i] * factor;
        }
        // é‡æ–°å½’ä¸€åŒ–åˆ°æ€»å’Œ100
        const total = adjustedProbs.reduce((a, b) => a + b, 0);
        for (let i = 0; i < 7; i++) {
            adjustedProbs[i] = (adjustedProbs[i] * 100) / total;
        }
    }
    
    const p = adjustedProbs.map(v => v / 100);
    const totalP = state.probs.reduce((a, b) => a + b, 0);
    const warningEl = document.getElementById('probWarning');
    warningEl.innerText = `å½“å‰æ€»æƒé‡: ${totalP}% | æœªè§¦å‘è®¡æ•°: ${state.currentMisses}`;
    warningEl.style.color = totalP === 100 ? 'var(--primary)' : 'var(--danger)';
    
    // æ›´æ–°æ˜¾ç¤º
    document.getElementById('currentMissesDisplay').textContent = state.currentMisses;

    // æ ¹æ®å½“å‰ç®—æ³•è®¡ç®—åˆ†æ•°
    const algorithm = state.currentAlgorithm;
    if (algorithm === 'greedy') {
        scores = Algorithms.greedy(p, state.grid);
    } else if (algorithm === 'weighted') {
        scores = Algorithms.weighted(p, state.grid, state.heuristicWeight);
    } else if (algorithm === 'entropy') {
        scores = Algorithms.entropy(p, state.grid);
    }
    
    // ç»Ÿè®¡æœªå¼€å¯æ ¼å­æ•°é‡å¹¶æ›´æ–°æ˜¾ç¤º
    for (let i = 0; i < 49; i++) {
        const el = document.getElementById(`cell-${i}`);
        el.classList.remove('best', 'good');
        if (state.grid[i]) continue;
        unopened++;
        // æ‰¾åˆ°å¯¹åº”çš„åˆ†æ•°
        const scoreObj = scores.find(s => s.i === i);
        if (scoreObj) {
            document.getElementById(`s-${i}`).innerText = scoreObj.score.toFixed(1);
        }
    }

    if(scores.length > 0){
        const max = Math.max(...scores.map(s => s.score));
        scores.forEach(s => {
            if(s.score === max && max > 0) document.getElementById(`cell-${s.i}`).classList.add('best');
            else if(s.score > max * 0.8 && max > 0) document.getElementById(`cell-${s.i}`).classList.add('good');
        });
    }

    if (unopened === 0 && state.clicks > 0) {
        document.getElementById('winOverlay').style.display = 'flex';
        document.getElementById('winMessage').innerText = `å·²é”å®šå…¨å›¾åæ ‡ï¼æœ¬è½®å…±åé¦ˆ ${state.clicks} æ¬¡ã€‚`;
        localStorage.removeItem(STORAGE_KEY);
    }
    document.getElementById('statusBar').innerText = `å‰©ä½™: ${unopened} | æœ¬å±€ç‚¹å‡»: ${state.clicks} | æœªè§¦å‘: ${state.currentMisses}`;
    saveState();
}

function runBatchSimulation() {
    const iterations = parseInt(document.getElementById('simIterations').value) || 1000;
    const currentAlgorithm = state.currentAlgorithm;
    
    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    const resultsDiv = document.getElementById('simResults');
    const contentDiv = document.getElementById('simResultsContent');
    resultsDiv.style.display = 'block';
    contentDiv.innerHTML = '<p>æ­£åœ¨è¿è¡Œæ¨¡æ‹Ÿï¼Œè¯·ç¨å€™...</p>';
    
    // ä½¿ç”¨ setTimeout é¿å…é˜»å¡ UI
    setTimeout(() => {
        // è¿è¡Œå½“å‰ç®—æ³•
        const currentResults = runSimulation(currentAlgorithm, iterations);
        // è¿è¡ŒåŸºç¡€è´ªå¿ƒç®—æ³•ä½œä¸ºå¯¹æ¯”
        const greedyResults = runSimulation('greedy', iterations);
        
        // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        const calcStats = (arr) => {
            const mean = arr.reduce((a,b) => a + b, 0) / arr.length;
            const variance = arr.reduce((a,b) => a + Math.pow(b - mean, 2), 0) / arr.length;
            const std = Math.sqrt(variance);
            return { mean, variance, std };
        };
        
        const currentStats = calcStats(currentResults);
        const greedyStats = calcStats(greedyResults);
        
        // è®¡ç®—å¼€å±€æœ€ä¼˜è§£çƒ­åŠ›åˆ†å¸ƒï¼ˆç¬¬ä¸€è½®æ¨¡æ‹Ÿçš„ç¬¬ä¸€ä¸ªé€‰æ‹©ï¼‰
        // æˆ‘ä»¬è¿è¡Œä¸€æ¬¡æ¨¡æ‹Ÿï¼Œè®°å½•æ¯ä¸ªæ ¼å­è¢«é€‰ä¸ºç¬¬ä¸€ä¸ªé€‰æ‹©çš„æ¬¡æ•°
        const heatmap = Array(49).fill(0);
        const sampleSize = Math.min(100, iterations);
        for (let i = 0; i < sampleSize; i++) {
            // åˆ›å»ºä¸€ä¸ªæ–°çš„æ¨¡æ‹Ÿï¼Œä½†åªè®°å½•ç¬¬ä¸€æ­¥
            const grid = Array(49).fill(false);
            let currentMisses = 0;
            // åŠ¨æ€æ¦‚ç‡è°ƒæ•´ï¼ˆä¸ä¹‹å‰ç›¸åŒï¼‰
            let adjustedProbs = [...state.probs];
            if (state.enablePity && currentMisses >= state.pityStart) {
                const progress = Math.min((currentMisses - state.pityStart + 1) / (state.pityMax - state.pityStart + 1), 1.0);
                const factor = 1 + 0.5 * progress;
                for (let j = 0; j < 6; j++) {
                    adjustedProbs[j] = state.probs[j] * factor;
                }
                const total = adjustedProbs.reduce((a, b) => a + b, 0);
                for (let j = 0; j < 7; j++) {
                    adjustedProbs[j] = (adjustedProbs[j] * 100) / total;
                }
            }
            const p = adjustedProbs.map(v => v / 100);
            
            let scores;
            if (currentAlgorithm === 'greedy') {
                scores = Algorithms.greedy(p, grid);
            } else if (currentAlgorithm === 'weighted') {
                scores = Algorithms.weighted(p, grid, state.heuristicWeight);
            } else if (currentAlgorithm === 'entropy') {
                scores = Algorithms.entropy(p, grid);
            }
            
            if (scores.length > 0) {
                let maxScore = -Infinity;
                let bestIndices = [];
                for (const s of scores) {
                    if (s.score > maxScore) {
                        maxScore = s.score;
                        bestIndices = [s.i];
                    } else if (s.score === maxScore) {
                        bestIndices.push(s.i);
                    }
                }
                if (bestIndices.length > 0) {
                    // éšæœºé€‰æ‹©ä¸€ä¸ªæœ€é«˜åˆ†æ ¼å­
                    const randomIndex = Math.floor(Math.random() * bestIndices.length);
                    const bestIdx = bestIndices[randomIndex];
                    heatmap[bestIdx]++;
                }
            }
        }
        
        // ç”Ÿæˆç»“æœ HTML
        let html = `
            <div style="background:#f8f9fa; padding:10px; border-radius:8px; margin-bottom:10px;">
                <h5 style="margin:0 0 8px 0;">å¯¹æ¯”ç»“æœ (${iterations} æ¬¡æ¨¡æ‹Ÿ)</h5>
                <table style="width:100%; font-size:11px; border-collapse:collapse;">
                    <tr>
                        <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">æŒ‡æ ‡</th>
                        <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">å½“å‰ç®—æ³• (${currentAlgorithm})</th>
                        <th style="text-align:left; padding:4px; border-bottom:1px solid #ddd;">åŸºç¡€è´ªå¿ƒ</th>
                    </tr>
                    <tr>
                        <td style="padding:4px; border-bottom:1px solid #eee;">å¹³å‡ç‚¹å‡»æ¬¡æ•°</td>
                        <td style="padding:4px; border-bottom:1px solid #eee;">${currentStats.mean.toFixed(2)}</td>
                        <td style="padding:4px; border-bottom:1px solid #eee;">${greedyStats.mean.toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td style="padding:4px; border-bottom:1px solid #eee;">æ–¹å·®</td>
                        <td style="padding:4px; border-bottom:1px solid #eee;">${currentStats.variance.toFixed(2)}</td>
                        <td style="padding:4px; border-bottom:1px solid #eee;">${greedyStats.variance.toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td style="padding:4px; border-bottom:1px solid #eee;">æ ‡å‡†å·®</td>
                        <td style="padding:4px; border-bottom:1px solid #eee;">${currentStats.std.toFixed(2)}</td>
                        <td style="padding:4px; border-bottom:1px solid #eee;">${greedyStats.std.toFixed(2)}</td>
                    </tr>
                </table>
            </div>
            <div style="background:#f8f9fa; padding:10px; border-radius:8px;">
                <h5 style="margin:0 0 8px 0;">å¼€å±€æœ€ä¼˜è§£çƒ­åŠ›åˆ†å¸ƒ (å‰${sampleSize}æ¬¡æ¨¡æ‹Ÿ)</h5>
                <div style="display:grid; grid-template-columns:repeat(7, 1fr); gap:2px;">
        `;
        for (let i = 0; i < 49; i++) {
            const intensity = Math.min(100, (heatmap[i] / sampleSize) * 100);
            html += `<div style="background:hsl(200, 70%, ${100 - intensity}%); text-align:center; font-size:8px; padding:4px;">${heatmap[i]}</div>`;
        }
        html += `
                </div>
                <p style="font-size:10px; color:#666; margin-top:5px;">æ•°å­—è¡¨ç¤ºè¢«é€‰ä¸ºç¬¬ä¸€æ­¥çš„æ¬¡æ•°</p>
            </div>
        `;
        
        contentDiv.innerHTML = html;
    }, 10);
}

function confirmReset() {
    if(confirm("ç¡®å®šé‡ç½®å—ï¼Ÿ")){
        state = JSON.parse(JSON.stringify(defaultData));
        localStorage.removeItem(STORAGE_KEY);
        document.getElementById('winOverlay').style.display = 'none';
        init();
    }
}
window.onload = init;
</script>
</body>
</html>
